!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A0	.\rand.c	57;"	d	file:
A1	.\rand.c	58;"	d	file:
A2	.\rand.c	59;"	d	file:
ACTIVE_EXPIRE_CYCLE_FAST	.\redis.h	130;"	d
ACTIVE_EXPIRE_CYCLE_FAST_DURATION	.\redis.h	127;"	d
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP	.\redis.h	126;"	d
ACTIVE_EXPIRE_CYCLE_SLOW	.\redis.h	129;"	d
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC	.\redis.h	128;"	d
ADDEQU	.\rand.c	53;"	d	file:
AE_ALL_EVENTS	.\ae.h	45;"	d
AE_DONT_WAIT	.\ae.h	46;"	d
AE_ERR	.\ae.h	37;"	d
AE_FILE_EVENTS	.\ae.h	43;"	d
AE_NOMORE	.\ae.h	48;"	d
AE_NONE	.\ae.h	39;"	d
AE_NOTUSED	.\ae.h	51;"	d
AE_OK	.\ae.h	36;"	d
AE_READABLE	.\ae.h	40;"	d
AE_TIME_EVENTS	.\ae.h	44;"	d
AE_WRITABLE	.\ae.h	41;"	d
AF_LOCAL	.\anet.h	39;"	d
AL_START_HEAD	.\adlist.h	92;"	d
AL_START_TAIL	.\adlist.h	93;"	d
ANET_CONNECT_NONBLOCK	.\anet.c	219;"	d	file:
ANET_CONNECT_NONE	.\anet.c	218;"	d	file:
ANET_ERR	.\anet.h	35;"	d
ANET_ERR_LEN	.\anet.h	36;"	d
ANET_H	.\anet.h	32;"	d
ANET_OK	.\anet.h	34;"	d
AOF_FSYNC_ALWAYS	.\redis.h	292;"	d
AOF_FSYNC_EVERYSEC	.\redis.h	293;"	d
AOF_FSYNC_NO	.\redis.h	291;"	d
AOF_RW_BUF_BLOCK_SIZE	.\aof.c	58;"	d	file:
AVOID_ERRNO	.\lzfP.h	100;"	d
BIG_ENDIAN	.\config.h	133;"	d
BIG_ENDIAN	.\config.h	167;"	d
BITOP_AND	.\bitops.c	100;"	d	file:
BITOP_NOT	.\bitops.c	103;"	d	file:
BITOP_OR	.\bitops.c	101;"	d	file:
BITOP_XOR	.\bitops.c	102;"	d	file:
BYTE_ORDER	.\config.h	140;"	d
BYTE_ORDER	.\config.h	150;"	d
BYTE_ORDER	.\config.h	170;"	d
BYTE_ORDER	.\config.h	172;"	d
C	.\rand.c	60;"	d	file:
CARRY	.\rand.c	52;"	d	file:
CHECK_INPUT	.\lzfP.h	121;"	d
CLI_HELP_COMMAND	.\redis-cli.c	133;"	d	file:
CLI_HELP_GROUP	.\redis-cli.c	134;"	d	file:
CRC64_H	.\crc64.h	2;"	d
CURR_OFFSET	.\redis-check-dump.c	113;"	d	file:
DICT_ERR	.\dict.h	42;"	d
DICT_HT_INITIAL_SIZE	.\dict.h	106;"	d
DICT_NOTUSED	.\dict.h	45;"	d
DICT_OK	.\dict.h	41;"	d
ERROR	.\redis-check-aof.c	39;"	d	file:
ERROR	.\redis-check-dump.c	98;"	d	file:
FRST	.\lzf_c.c	48;"	d	file:
GNUC_VERSION	.\config.h	189;"	d
HAVE_ATOMIC	.\config.h	191;"	d
HAVE_BACKTRACE	.\config.h	60;"	d
HAVE_EPOLL	.\config.h	65;"	d
HAVE_EVPORT	.\config.h	75;"	d
HAVE_KQUEUE	.\config.h	69;"	d
HAVE_MALLOC_SIZE	.\zmalloc.h	42;"	d
HAVE_MALLOC_SIZE	.\zmalloc.h	52;"	d
HAVE_MALLOC_SIZE	.\zmalloc.h	60;"	d
HAVE_PROC_MAPS	.\config.h	49;"	d
HAVE_PROC_SMAPS	.\config.h	50;"	d
HAVE_PROC_STAT	.\config.h	48;"	d
HAVE_SETPROCTITLE	.\setproctitle.c	42;"	d	file:
HAVE_SYNC_FILE_RANGE	.\config.h	93;"	d
HAVE_SYNC_FILE_RANGE	.\config.h	97;"	d
HAVE_TASKINFO	.\config.h	55;"	d
HIGH	.\rand.c	49;"	d	file:
HI_BIT	.\rand.c	66;"	d	file:
HLOG	.\lzfP.h	55;"	d
HSIZE	.\lzf_c.c	39;"	d	file:
IDX	.\lzf_c.c	51;"	d	file:
IDX	.\lzf_c.c	53;"	d	file:
IDX	.\lzf_c.c	55;"	d	file:
INIT_HTAB	.\lzfP.h	91;"	d
INIT_SETPROCTITLE_REPLACEMENT	.\config.h	117;"	d
INT24_MAX	.\ziplist.c	135;"	d	file:
INT24_MIN	.\ziplist.c	136;"	d	file:
INTSET_ENC_INT16	.\intset.c	40;"	d	file:
INTSET_ENC_INT32	.\intset.c	41;"	d	file:
INTSET_ENC_INT64	.\intset.c	42;"	d	file:
LATENCY_HISTORY_DEFAULT_INTERVAL	.\redis-cli.c	971;"	d	file:
LATENCY_SAMPLE_RATE	.\redis-cli.c	970;"	d	file:
LINE_BUFLEN	.\redis-cli.c	828;"	d	file:
LITTLE_ENDIAN	.\config.h	132;"	d
LITTLE_ENDIAN	.\config.h	164;"	d
LOW	.\rand.c	48;"	d	file:
LZFP_h	.\lzfP.h	38;"	d
LZF_H	.\lzf.h	38;"	d
LZF_STATE	.\lzfP.h	/^typedef const u8 *LZF_STATE[1 << (HLOG)];$/;"	t
LZF_STATE_ARG	.\lzfP.h	109;"	d
LZF_VERSION	.\lzf.h	49;"	d
MASK	.\rand.c	47;"	d	file:
MAX_EVENT_BATCHSZ	.\ae_evport.c	66;"	d	file:
MAX_LIT	.\lzf_c.c	74;"	d	file:
MAX_OFF	.\lzf_c.c	75;"	d	file:
MAX_REF	.\lzf_c.c	76;"	d	file:
MEMTEST_32BIT	.\memtest.c	41;"	d	file:
MEMTEST_64BIT	.\memtest.c	43;"	d	file:
MEMTEST_MAX_REGIONS	.\debug.c	711;"	d	file:
MUL	.\rand.c	50;"	d	file:
N	.\rand.c	46;"	d	file:
NEXT	.\lzf_c.c	49;"	d	file:
OPVAL_DIRTY_LL	.\t_zset.c	1188;"	d	file:
OPVAL_DIRTY_ROBJ	.\t_zset.c	1187;"	d	file:
OPVAL_VALID_LL	.\t_zset.c	1189;"	d	file:
OUTPUT_CSV	.\redis-cli.c	59;"	d	file:
OUTPUT_RAW	.\redis-cli.c	58;"	d	file:
OUTPUT_STANDARD	.\redis-cli.c	57;"	d	file:
PDP_ENDIAN	.\config.h	134;"	d
PREFIX_SIZE	.\zmalloc.c	48;"	d	file:
PREFIX_SIZE	.\zmalloc.c	51;"	d	file:
PREFIX_SIZE	.\zmalloc.c	53;"	d	file:
PSYNC_CONTINUE	.\replication.c	922;"	d	file:
PSYNC_FULLRESYNC	.\replication.c	923;"	d	file:
PSYNC_NOT_SUPPORTED	.\replication.c	924;"	d	file:
R0	.\sha1.c	49;"	d	file:
R1	.\sha1.c	50;"	d	file:
R2	.\sha1.c	51;"	d	file:
R3	.\sha1.c	52;"	d	file:
R4	.\sha1.c	53;"	d	file:
RANDPTR_INITIAL_SIZE	.\redis-benchmark.c	50;"	d	file:
REDIS_AGGR_MAX	.\t_zset.c	1476;"	d	file:
REDIS_AGGR_MIN	.\t_zset.c	1475;"	d	file:
REDIS_AGGR_SUM	.\t_zset.c	1474;"	d	file:
REDIS_AOF_AUTOSYNC_BYTES	.\redis.h	139;"	d
REDIS_AOF_OFF	.\redis.h	211;"	d
REDIS_AOF_ON	.\redis.h	212;"	d
REDIS_AOF_REWRITE_ITEMS_PER_CMD	.\redis.h	85;"	d
REDIS_AOF_REWRITE_MIN_SIZE	.\redis.h	84;"	d
REDIS_AOF_REWRITE_PERC	.\redis.h	83;"	d
REDIS_AOF_WAIT_REWRITE	.\redis.h	213;"	d
REDIS_ASKING	.\redis.h	226;"	d
REDIS_AUTHPASS_MAX_LEN	.\redis.h	89;"	d
REDIS_BGSAVE_RETRY_DELAY	.\redis.h	98;"	d
REDIS_BINDADDR_MAX	.\redis.h	124;"	d
REDIS_BIO_AOF_FSYNC	.\bio.h	40;"	d
REDIS_BIO_CLOSE_FILE	.\bio.h	39;"	d
REDIS_BIO_NUM_OPS	.\bio.h	41;"	d
REDIS_BLOCKED	.\redis.h	220;"	d
REDIS_CALL_FULL	.\redis.h	336;"	d
REDIS_CALL_NONE	.\redis.h	332;"	d
REDIS_CALL_PROPAGATE	.\redis.h	335;"	d
REDIS_CALL_SLOWLOG	.\redis.h	333;"	d
REDIS_CALL_STATS	.\redis.h	334;"	d
REDIS_CLIENT_LIMIT_CLASS_NORMAL	.\redis.h	241;"	d
REDIS_CLIENT_LIMIT_CLASS_PUBSUB	.\redis.h	243;"	d
REDIS_CLIENT_LIMIT_CLASS_SLAVE	.\redis.h	242;"	d
REDIS_CLIENT_LIMIT_NUM_CLASSES	.\redis.h	244;"	d
REDIS_CLI_KEEPALIVE_INTERVAL	.\redis-cli.c	60;"	d	file:
REDIS_CLOSE_AFTER_REPLY	.\redis.h	222;"	d
REDIS_CLOSE_ASAP	.\redis.h	227;"	d
REDIS_CMD_ADMIN	.\redis.h	155;"	d
REDIS_CMD_DENYOOM	.\redis.h	153;"	d
REDIS_CMD_LOADING	.\redis.h	160;"	d
REDIS_CMD_NOSCRIPT	.\redis.h	157;"	d
REDIS_CMD_NOT_USED_1	.\redis.h	154;"	d
REDIS_CMD_PUBSUB	.\redis.h	156;"	d
REDIS_CMD_RANDOM	.\redis.h	158;"	d
REDIS_CMD_READONLY	.\redis.h	152;"	d
REDIS_CMD_SKIP_MONITOR	.\redis.h	162;"	d
REDIS_CMD_SORT_FOR_SCRIPT	.\redis.h	159;"	d
REDIS_CMD_STALE	.\redis.h	161;"	d
REDIS_CMD_WRITE	.\redis.h	151;"	d
REDIS_COMPARE_BINARY	.\object.c	367;"	d	file:
REDIS_COMPARE_COLL	.\object.c	368;"	d	file:
REDIS_CONFIGLINE_MAX	.\redis.h	76;"	d
REDIS_CONFIG_REWRITE_SIGNATURE	.\config.c	1117;"	d	file:
REDIS_DBCRON_DBS_PER_CALL	.\redis.h	77;"	d
REDIS_DEBUG	.\redis.h	277;"	d
REDIS_DEFAULT_ACTIVE_REHASHING	.\redis.h	118;"	d
REDIS_DEFAULT_AOF_FILENAME	.\redis.h	116;"	d
REDIS_DEFAULT_AOF_FSYNC	.\redis.h	294;"	d
REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE	.\redis.h	117;"	d
REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC	.\redis.h	119;"	d
REDIS_DEFAULT_CLUSTER_CONFIG_FILE	.\redis.h	101;"	d
REDIS_DEFAULT_DAEMONIZE	.\redis.h	102;"	d
REDIS_DEFAULT_DBNUM	.\redis.h	75;"	d
REDIS_DEFAULT_HZ	.\redis.h	70;"	d
REDIS_DEFAULT_LOGFILE	.\redis.h	105;"	d
REDIS_DEFAULT_MAXMEMORY	.\redis.h	114;"	d
REDIS_DEFAULT_MAXMEMORY_POLICY	.\redis.h	317;"	d
REDIS_DEFAULT_MAXMEMORY_SAMPLES	.\redis.h	115;"	d
REDIS_DEFAULT_MIN_SLAVES_MAX_LAG	.\redis.h	121;"	d
REDIS_DEFAULT_MIN_SLAVES_TO_WRITE	.\redis.h	120;"	d
REDIS_DEFAULT_PID_FILE	.\redis.h	99;"	d
REDIS_DEFAULT_PIPE_TIMEOUT	.\redis-cli.c	61;"	d	file:
REDIS_DEFAULT_RDB_CHECKSUM	.\redis.h	109;"	d
REDIS_DEFAULT_RDB_COMPRESSION	.\redis.h	108;"	d
REDIS_DEFAULT_RDB_FILENAME	.\redis.h	110;"	d
REDIS_DEFAULT_REPL_BACKLOG_SIZE	.\redis.h	95;"	d
REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT	.\redis.h	96;"	d
REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY	.\redis.h	113;"	d
REDIS_DEFAULT_SLAVE_PRIORITY	.\redis.h	90;"	d
REDIS_DEFAULT_SLAVE_READ_ONLY	.\redis.h	112;"	d
REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA	.\redis.h	111;"	d
REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR	.\redis.h	107;"	d
REDIS_DEFAULT_SYSLOG_ENABLED	.\redis.h	106;"	d
REDIS_DEFAULT_SYSLOG_IDENT	.\redis.h	100;"	d
REDIS_DEFAULT_TCP_KEEPALIVE	.\redis.h	104;"	d
REDIS_DEFAULT_UNIX_SOCKET_PERM	.\redis.h	103;"	d
REDIS_DEFAULT_VERBOSITY	.\redis.h	282;"	d
REDIS_DIRTY_CAS	.\redis.h	221;"	d
REDIS_DIRTY_EXEC	.\redis.h	229;"	d
REDIS_ENCODING_HT	.\redis-check-dump.c	63;"	d	file:
REDIS_ENCODING_HT	.\redis.h	176;"	d
REDIS_ENCODING_INT	.\redis-check-dump.c	61;"	d	file:
REDIS_ENCODING_INT	.\redis.h	175;"	d
REDIS_ENCODING_INTSET	.\redis.h	180;"	d
REDIS_ENCODING_LINKEDLIST	.\redis.h	178;"	d
REDIS_ENCODING_RAW	.\redis-check-dump.c	60;"	d	file:
REDIS_ENCODING_RAW	.\redis.h	174;"	d
REDIS_ENCODING_SKIPLIST	.\redis.h	181;"	d
REDIS_ENCODING_ZIPLIST	.\redis.h	179;"	d
REDIS_ENCODING_ZIPMAP	.\redis-check-dump.c	62;"	d	file:
REDIS_ENCODING_ZIPMAP	.\redis.h	177;"	d
REDIS_EOF	.\redis-check-dump.c	69;"	d	file:
REDIS_ERR	.\redis.h	67;"	d
REDIS_EVENTLOOP_FDSET_INCR	.\redis.h	144;"	d
REDIS_EXPIRETIME	.\redis-check-dump.c	67;"	d	file:
REDIS_EXPIRETIME_MS	.\redis-check-dump.c	66;"	d	file:
REDIS_FORCE_AOF	.\redis.h	231;"	d
REDIS_FORCE_REPL	.\redis.h	232;"	d
REDIS_GETKEYS_ALL	.\redis.h	1214;"	d
REDIS_GETKEYS_PRELOAD	.\redis.h	1215;"	d
REDIS_HASH	.\redis-check-dump.c	50;"	d	file:
REDIS_HASH	.\redis.h	169;"	d
REDIS_HASH_KEY	.\redis.h	893;"	d
REDIS_HASH_MAX_ZIPLIST_ENTRIES	.\redis.h	297;"	d
REDIS_HASH_MAX_ZIPLIST_VALUE	.\redis.h	298;"	d
REDIS_HASH_VALUE	.\redis.h	894;"	d
REDIS_HASH_ZIPLIST	.\redis-check-dump.c	55;"	d	file:
REDIS_HASH_ZIPMAP	.\redis-check-dump.c	51;"	d	file:
REDIS_HEAD	.\redis.h	267;"	d
REDIS_HT_MINFILL	.\redis.h	147;"	d
REDIS_INLINE_MAX_SIZE	.\redis.h	136;"	d
REDIS_IOBUF_LEN	.\redis.h	134;"	d
REDIS_IP_STR_LEN	.\redis.h	122;"	d
REDIS_LIST	.\redis-check-dump.c	47;"	d	file:
REDIS_LIST	.\redis.h	166;"	d
REDIS_LIST_MAX_ZIPLIST_ENTRIES	.\redis.h	299;"	d
REDIS_LIST_MAX_ZIPLIST_VALUE	.\redis.h	300;"	d
REDIS_LIST_ZIPLIST	.\redis-check-dump.c	52;"	d	file:
REDIS_LOG_RAW	.\redis.h	281;"	d
REDIS_LONGSTR_SIZE	.\redis.h	138;"	d
REDIS_LRAND48_MAX	.\rand.h	36;"	d
REDIS_LRU_CLOCK_MAX	.\redis.h	375;"	d
REDIS_LRU_CLOCK_RESOLUTION	.\redis.h	376;"	d
REDIS_LUA_CLIENT	.\redis.h	225;"	d
REDIS_LUA_TIME_LIMIT	.\redis.h	320;"	d
REDIS_MASTER	.\redis.h	217;"	d
REDIS_MASTER_FORCE_REPLY	.\redis.h	230;"	d
REDIS_MAXIDLETIME	.\redis.h	74;"	d
REDIS_MAXMEMORY_ALLKEYS_LRU	.\redis.h	314;"	d
REDIS_MAXMEMORY_ALLKEYS_RANDOM	.\redis.h	315;"	d
REDIS_MAXMEMORY_NO_EVICTION	.\redis.h	316;"	d
REDIS_MAXMEMORY_VOLATILE_LRU	.\redis.h	311;"	d
REDIS_MAXMEMORY_VOLATILE_RANDOM	.\redis.h	313;"	d
REDIS_MAXMEMORY_VOLATILE_TTL	.\redis.h	312;"	d
REDIS_MAX_CLIENTS	.\redis.h	88;"	d
REDIS_MAX_HZ	.\redis.h	72;"	d
REDIS_MAX_LOGMSG_LEN	.\redis.h	82;"	d
REDIS_MAX_QUERYBUF_LEN	.\redis.h	133;"	d
REDIS_MAX_WRITE_PER_EVENT	.\redis.h	78;"	d
REDIS_MBULK_BIG_ARG	.\redis.h	137;"	d
REDIS_MIN_HZ	.\redis.h	71;"	d
REDIS_MONITOR	.\redis.h	218;"	d
REDIS_MULTI	.\redis.h	219;"	d
REDIS_NOTICE	.\redis.h	279;"	d
REDIS_NOTIFY_ALL	.\redis.h	355;"	d
REDIS_NOTIFY_EVICTED	.\redis.h	354;"	d
REDIS_NOTIFY_EXPIRED	.\redis.h	353;"	d
REDIS_NOTIFY_GENERIC	.\redis.h	347;"	d
REDIS_NOTIFY_HASH	.\redis.h	351;"	d
REDIS_NOTIFY_KEYEVENT	.\redis.h	346;"	d
REDIS_NOTIFY_KEYSPACE	.\redis.h	345;"	d
REDIS_NOTIFY_LIST	.\redis.h	349;"	d
REDIS_NOTIFY_SET	.\redis.h	350;"	d
REDIS_NOTIFY_STRING	.\redis.h	348;"	d
REDIS_NOTIFY_ZSET	.\redis.h	352;"	d
REDIS_NOTUSED	.\redis-benchmark.c	49;"	d	file:
REDIS_NOTUSED	.\redis-cli.c	55;"	d	file:
REDIS_NOTUSED	.\redis.h	285;"	d
REDIS_OK	.\redis.h	66;"	d
REDIS_OPS_SEC_SAMPLES	.\redis.h	94;"	d
REDIS_OP_DIFF	.\redis.h	307;"	d
REDIS_OP_DIFF	.\t_set.c	739;"	d	file:
REDIS_OP_INTER	.\redis.h	308;"	d
REDIS_OP_INTER	.\t_set.c	740;"	d	file:
REDIS_OP_UNION	.\redis.h	306;"	d
REDIS_OP_UNION	.\t_set.c	738;"	d	file:
REDIS_PEER_ID_LEN	.\redis.h	123;"	d
REDIS_PRE_PSYNC_SLAVE	.\redis.h	233;"	d
REDIS_PROPAGATE_AOF	.\redis.h	340;"	d
REDIS_PROPAGATE_NONE	.\redis.h	339;"	d
REDIS_PROPAGATE_REPL	.\redis.h	341;"	d
REDIS_RANDOM_H	.\rand.h	31;"	d
REDIS_RDB_14BITLEN	.\rdb.h	59;"	d
REDIS_RDB_14BITLEN	.\redis-check-dump.c	85;"	d	file:
REDIS_RDB_14BITLEN	.\redis.h	197;"	d
REDIS_RDB_32BITLEN	.\rdb.h	60;"	d
REDIS_RDB_32BITLEN	.\redis-check-dump.c	86;"	d	file:
REDIS_RDB_32BITLEN	.\redis.h	198;"	d
REDIS_RDB_6BITLEN	.\rdb.h	58;"	d
REDIS_RDB_6BITLEN	.\redis-check-dump.c	84;"	d	file:
REDIS_RDB_6BITLEN	.\redis.h	196;"	d
REDIS_RDB_ENCVAL	.\rdb.h	61;"	d
REDIS_RDB_ENCVAL	.\redis-check-dump.c	87;"	d	file:
REDIS_RDB_ENCVAL	.\redis.h	199;"	d
REDIS_RDB_ENC_INT16	.\rdb.h	69;"	d
REDIS_RDB_ENC_INT16	.\redis-check-dump.c	94;"	d	file:
REDIS_RDB_ENC_INT16	.\redis.h	206;"	d
REDIS_RDB_ENC_INT32	.\rdb.h	70;"	d
REDIS_RDB_ENC_INT32	.\redis-check-dump.c	95;"	d	file:
REDIS_RDB_ENC_INT32	.\redis.h	207;"	d
REDIS_RDB_ENC_INT8	.\rdb.h	68;"	d
REDIS_RDB_ENC_INT8	.\redis-check-dump.c	93;"	d	file:
REDIS_RDB_ENC_INT8	.\redis.h	205;"	d
REDIS_RDB_ENC_LZF	.\rdb.h	71;"	d
REDIS_RDB_ENC_LZF	.\redis-check-dump.c	96;"	d	file:
REDIS_RDB_ENC_LZF	.\redis.h	208;"	d
REDIS_RDB_LENERR	.\rdb.h	62;"	d
REDIS_RDB_LENERR	.\redis-check-dump.c	88;"	d	file:
REDIS_RDB_LENERR	.\redis.h	200;"	d
REDIS_RDB_OPCODE_EOF	.\rdb.h	98;"	d
REDIS_RDB_OPCODE_EXPIRETIME	.\rdb.h	96;"	d
REDIS_RDB_OPCODE_EXPIRETIME_MS	.\rdb.h	95;"	d
REDIS_RDB_OPCODE_SELECTDB	.\rdb.h	97;"	d
REDIS_RDB_TYPE_HASH	.\rdb.h	80;"	d
REDIS_RDB_TYPE_HASH_ZIPLIST	.\rdb.h	88;"	d
REDIS_RDB_TYPE_HASH_ZIPMAP	.\rdb.h	84;"	d
REDIS_RDB_TYPE_LIST	.\rdb.h	77;"	d
REDIS_RDB_TYPE_LIST_ZIPLIST	.\rdb.h	85;"	d
REDIS_RDB_TYPE_SET	.\rdb.h	78;"	d
REDIS_RDB_TYPE_SET_INTSET	.\rdb.h	86;"	d
REDIS_RDB_TYPE_STRING	.\rdb.h	76;"	d
REDIS_RDB_TYPE_ZSET	.\rdb.h	79;"	d
REDIS_RDB_TYPE_ZSET_ZIPLIST	.\rdb.h	87;"	d
REDIS_RDB_VERSION	.\rdb.h	41;"	d
REDIS_REPLY_CHUNK_BYTES	.\redis.h	135;"	d
REDIS_REPL_BACKLOG_MIN_SIZE	.\redis.h	97;"	d
REDIS_REPL_CONNECT	.\redis.h	248;"	d
REDIS_REPL_CONNECTED	.\redis.h	252;"	d
REDIS_REPL_CONNECTING	.\redis.h	249;"	d
REDIS_REPL_NONE	.\redis.h	247;"	d
REDIS_REPL_ONLINE	.\redis.h	261;"	d
REDIS_REPL_PING_SLAVE_PERIOD	.\redis.h	92;"	d
REDIS_REPL_RECEIVE_PONG	.\redis.h	250;"	d
REDIS_REPL_SEND_BULK	.\redis.h	260;"	d
REDIS_REPL_SYNCIO_TIMEOUT	.\redis.h	264;"	d
REDIS_REPL_TIMEOUT	.\redis.h	91;"	d
REDIS_REPL_TRANSFER	.\redis.h	251;"	d
REDIS_REPL_WAIT_BGSAVE_END	.\redis.h	259;"	d
REDIS_REPL_WAIT_BGSAVE_START	.\redis.h	258;"	d
REDIS_REQ_INLINE	.\redis.h	236;"	d
REDIS_REQ_MULTIBULK	.\redis.h	237;"	d
REDIS_RUN_ID_SIZE	.\redis.h	93;"	d
REDIS_SELECTDB	.\redis-check-dump.c	68;"	d	file:
REDIS_SENTINEL_PORT	.\sentinel.c	43;"	d	file:
REDIS_SERVERPORT	.\redis.h	73;"	d
REDIS_SET	.\redis-check-dump.c	48;"	d	file:
REDIS_SET	.\redis.h	167;"	d
REDIS_SET_INTSET	.\redis-check-dump.c	53;"	d	file:
REDIS_SET_MAX_INTSET_ENTRIES	.\redis.h	301;"	d
REDIS_SET_NO_FLAGS	.\t_string.c	61;"	d	file:
REDIS_SET_NX	.\t_string.c	62;"	d	file:
REDIS_SET_XX	.\t_string.c	63;"	d	file:
REDIS_SHARED_BULKHDR_LEN	.\redis.h	81;"	d
REDIS_SHARED_INTEGERS	.\redis.h	80;"	d
REDIS_SHARED_SELECT_CMDS	.\redis.h	79;"	d
REDIS_SHUTDOWN_NOSAVE	.\redis.h	329;"	d
REDIS_SHUTDOWN_SAVE	.\redis.h	327;"	d
REDIS_SLAVE	.\redis.h	216;"	d
REDIS_SLOWLOG_LOG_SLOWER_THAN	.\redis.h	86;"	d
REDIS_SLOWLOG_MAX_LEN	.\redis.h	87;"	d
REDIS_SORTKEY_MAX	.\redis.h	274;"	d
REDIS_SORT_ASC	.\redis.h	272;"	d
REDIS_SORT_DESC	.\redis.h	273;"	d
REDIS_SORT_GET	.\redis.h	271;"	d
REDIS_STRING	.\redis-check-dump.c	46;"	d	file:
REDIS_STRING	.\redis.h	165;"	d
REDIS_SYNCIO_RESOLUTION	.\syncio.c	43;"	d	file:
REDIS_TAIL	.\redis.h	268;"	d
REDIS_THREAD_STACK_SIZE	.\bio.c	89;"	d	file:
REDIS_UNBLOCKED	.\redis.h	223;"	d
REDIS_UNIX_SOCKET	.\redis.h	228;"	d
REDIS_VERBOSE	.\redis.h	278;"	d
REDIS_VERSION	.\version.h	1;"	d
REDIS_WARNING	.\redis.h	280;"	d
REDIS_ZSET	.\redis-check-dump.c	49;"	d	file:
REDIS_ZSET	.\redis.h	168;"	d
REDIS_ZSET_MAX_ZIPLIST_ENTRIES	.\redis.h	302;"	d
REDIS_ZSET_MAX_ZIPLIST_VALUE	.\redis.h	303;"	d
REDIS_ZSET_ZIPLIST	.\redis-check-dump.c	54;"	d	file:
REPL_MAX_WRITTEN_BEFORE_FSYNC	.\replication.c	730;"	d	file:
REST	.\rand.c	64;"	d	file:
R_Nan	.\redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Nan	.\redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_NegInf	.\redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_NegInf	.\redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_PosInf	.\redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_PosInf	.\redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_Zero	.\redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Zero	.\redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
SDS_MAX_PREALLOC	.\sds.h	34;"	d
SEED	.\rand.c	63;"	d	file:
SENTINEL_ASK_FORCED	.\sentinel.c	2673;"	d	file:
SENTINEL_ASK_PERIOD	.\sentinel.c	76;"	d	file:
SENTINEL_DEFAULT_DOWN_AFTER	.\sentinel.c	78;"	d	file:
SENTINEL_DEFAULT_FAILOVER_TIMEOUT	.\sentinel.c	86;"	d	file:
SENTINEL_DEFAULT_PARALLEL_SYNCS	.\sentinel.c	84;"	d	file:
SENTINEL_DEFAULT_SLAVE_PRIORITY	.\sentinel.c	82;"	d	file:
SENTINEL_ELECTION_TIMEOUT	.\sentinel.c	88;"	d	file:
SENTINEL_FAILOVER_STATE_NONE	.\sentinel.c	91;"	d	file:
SENTINEL_FAILOVER_STATE_RECONF_SLAVES	.\sentinel.c	96;"	d	file:
SENTINEL_FAILOVER_STATE_SELECT_SLAVE	.\sentinel.c	93;"	d	file:
SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE	.\sentinel.c	94;"	d	file:
SENTINEL_FAILOVER_STATE_UPDATE_CONFIG	.\sentinel.c	97;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_PROMOTION	.\sentinel.c	95;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_START	.\sentinel.c	92;"	d	file:
SENTINEL_GENERATE_EVENT	.\sentinel.c	106;"	d	file:
SENTINEL_HELLO_CHANNEL	.\sentinel.c	79;"	d	file:
SENTINEL_INFO_PERIOD	.\sentinel.c	74;"	d	file:
SENTINEL_LEADER	.\sentinel.c	107;"	d	file:
SENTINEL_MASTER_LINK_STATUS_DOWN	.\sentinel.c	100;"	d	file:
SENTINEL_MASTER_LINK_STATUS_UP	.\sentinel.c	99;"	d	file:
SENTINEL_MAX_PENDING_COMMANDS	.\sentinel.c	87;"	d	file:
SENTINEL_MIN_LINK_RECONNECT_PERIOD	.\sentinel.c	85;"	d	file:
SENTINEL_NO_FLAGS	.\sentinel.c	105;"	d	file:
SENTINEL_OBSERVER	.\sentinel.c	108;"	d	file:
SENTINEL_PING_PERIOD	.\sentinel.c	75;"	d	file:
SENTINEL_PUBLISH_PERIOD	.\sentinel.c	77;"	d	file:
SENTINEL_RESET_NO_SENTINELS	.\sentinel.c	1110;"	d	file:
SENTINEL_SCRIPT_MAX_ARGS	.\sentinel.c	566;"	d	file:
SENTINEL_SCRIPT_MAX_QUEUE	.\sentinel.c	113;"	d	file:
SENTINEL_SCRIPT_MAX_RETRY	.\sentinel.c	116;"	d	file:
SENTINEL_SCRIPT_MAX_RUNNING	.\sentinel.c	114;"	d	file:
SENTINEL_SCRIPT_MAX_RUNTIME	.\sentinel.c	115;"	d	file:
SENTINEL_SCRIPT_NONE	.\sentinel.c	111;"	d	file:
SENTINEL_SCRIPT_RETRY_DELAY	.\sentinel.c	117;"	d	file:
SENTINEL_SCRIPT_RUNNING	.\sentinel.c	112;"	d	file:
SENTINEL_SLAVE_RECONF_RETRY_PERIOD	.\sentinel.c	83;"	d	file:
SENTINEL_TILT_PERIOD	.\sentinel.c	81;"	d	file:
SENTINEL_TILT_TRIGGER	.\sentinel.c	80;"	d	file:
SET3	.\rand.c	61;"	d	file:
SETLOW	.\rand.c	62;"	d	file:
SET_ERRNO	.\lzf_d.c	40;"	d	file:
SET_ERRNO	.\lzf_d.c	43;"	d	file:
SHA1Final	.\sha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f
SHA1HANDSOFF	.\sha1.c	22;"	d	file:
SHA1Init	.\sha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f
SHA1Transform	.\sha1.c	/^void SHA1Transform(u_int32_t state[5], const unsigned char buffer[64])$/;"	f
SHA1Update	.\sha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, u_int32_t len)$/;"	f
SHA1_CTX	.\sha1.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon17
SHIFT_ERROR	.\redis-check-dump.c	123;"	d	file:
SLOWLOG_ENTRY_MAX_ARGC	.\slowlog.h	30;"	d
SLOWLOG_ENTRY_MAX_STRING	.\slowlog.h	31;"	d
SPT	.\setproctitle.c	/^} SPT;$/;"	v	typeref:struct:__anon16	file:
SPT_MAXTITLE	.\setproctitle.c	217;"	d	file:
SPT_MIN	.\setproctitle.c	68;"	d	file:
SRANDMEMBER_SUB_STRATEGY_MUL	.\t_set.c	419;"	d	file:
SRI_DISCONNECTED	.\sentinel.c	59;"	d	file:
SRI_FAILOVER_IN_PROGRESS	.\sentinel.c	64;"	d	file:
SRI_FORCE_FAILOVER	.\sentinel.c	70;"	d	file:
SRI_MASTER	.\sentinel.c	56;"	d	file:
SRI_MASTER_DOWN	.\sentinel.c	62;"	d	file:
SRI_O_DOWN	.\sentinel.c	61;"	d	file:
SRI_PROMOTED	.\sentinel.c	66;"	d	file:
SRI_RECONF_DONE	.\sentinel.c	69;"	d	file:
SRI_RECONF_INPROG	.\sentinel.c	68;"	d	file:
SRI_RECONF_SENT	.\sentinel.c	67;"	d	file:
SRI_SCRIPT_KILL_SENT	.\sentinel.c	71;"	d	file:
SRI_SENTINEL	.\sentinel.c	58;"	d	file:
SRI_SLAVE	.\sentinel.c	57;"	d	file:
SRI_S_DOWN	.\sentinel.c	60;"	d	file:
STANDALONE	.\lzfP.h	40;"	d
STRICT_ALIGN	.\lzfP.h	139;"	d
STRICT_ALIGN	.\lzfP.h	140;"	d
STRICT_ALIGN	.\lzfP.h	82;"	d
SWAPINIT	.\pqsort.c	65;"	d	file:
TYPE_HASH	.\redis-cli.c	1274;"	d	file:
TYPE_LIST	.\redis-cli.c	1272;"	d	file:
TYPE_SET	.\redis-cli.c	1273;"	d	file:
TYPE_STRING	.\redis-cli.c	1271;"	d	file:
TYPE_ZSET	.\redis-cli.c	1275;"	d	file:
ULONG_ONEZERO	.\memtest.c	49;"	d	file:
ULONG_ONEZERO	.\memtest.c	52;"	d	file:
ULONG_ZEROONE	.\memtest.c	50;"	d	file:
ULONG_ZEROONE	.\memtest.c	53;"	d	file:
ULTRA_FAST	.\lzfP.h	75;"	d
UNIT_MILLISECONDS	.\redis.h	324;"	d
UNIT_SECONDS	.\redis.h	323;"	d
USE_SETPROCTITLE	.\config.h	112;"	d
USE_SETPROCTITLE	.\config.h	116;"	d
VERY_FAST	.\lzfP.h	146;"	d
VERY_FAST	.\lzfP.h	64;"	d
X0	.\rand.c	54;"	d	file:
X1	.\rand.c	55;"	d	file:
X2	.\rand.c	56;"	d	file:
ZIPLIST_BYTES	.\ziplist.c	142;"	d	file:
ZIPLIST_ENTRY_END	.\ziplist.c	148;"	d	file:
ZIPLIST_ENTRY_HEAD	.\ziplist.c	146;"	d	file:
ZIPLIST_ENTRY_TAIL	.\ziplist.c	147;"	d	file:
ZIPLIST_HEAD	.\ziplist.h	31;"	d
ZIPLIST_HEADER_SIZE	.\ziplist.c	145;"	d	file:
ZIPLIST_INCR_LENGTH	.\ziplist.c	152;"	d	file:
ZIPLIST_LENGTH	.\ziplist.c	144;"	d	file:
ZIPLIST_TAIL	.\ziplist.h	32;"	d
ZIPLIST_TAIL_OFFSET	.\ziplist.c	143;"	d	file:
ZIPMAP_BIGLEN	.\zipmap.c	84;"	d	file:
ZIPMAP_END	.\zipmap.c	85;"	d	file:
ZIPMAP_LEN_BYTES	.\zipmap.c	94;"	d	file:
ZIPMAP_VALUE_MAX_FREE	.\zipmap.c	89;"	d	file:
ZIP_BIGLEN	.\ziplist.c	116;"	d	file:
ZIP_DECODE_LENGTH	.\ziplist.c	226;"	d	file:
ZIP_DECODE_PREVLEN	.\ziplist.c	289;"	d	file:
ZIP_DECODE_PREVLENSIZE	.\ziplist.c	279;"	d	file:
ZIP_END	.\ziplist.c	115;"	d	file:
ZIP_ENTRY_ENCODING	.\ziplist.c	167;"	d	file:
ZIP_INT_16B	.\ziplist.c	124;"	d	file:
ZIP_INT_24B	.\ziplist.c	127;"	d	file:
ZIP_INT_32B	.\ziplist.c	125;"	d	file:
ZIP_INT_64B	.\ziplist.c	126;"	d	file:
ZIP_INT_8B	.\ziplist.c	128;"	d	file:
ZIP_INT_IMM_MASK	.\ziplist.c	130;"	d	file:
ZIP_INT_IMM_MAX	.\ziplist.c	132;"	d	file:
ZIP_INT_IMM_MIN	.\ziplist.c	131;"	d	file:
ZIP_INT_IMM_VAL	.\ziplist.c	133;"	d	file:
ZIP_INT_MASK	.\ziplist.c	120;"	d	file:
ZIP_IS_STR	.\ziplist.c	139;"	d	file:
ZIP_STR_06B	.\ziplist.c	121;"	d	file:
ZIP_STR_14B	.\ziplist.c	122;"	d	file:
ZIP_STR_32B	.\ziplist.c	123;"	d	file:
ZIP_STR_MASK	.\ziplist.c	119;"	d	file:
ZMALLOC_LIB	.\zmalloc.h	39;"	d
ZMALLOC_LIB	.\zmalloc.h	49;"	d
ZMALLOC_LIB	.\zmalloc.h	65;"	d
ZSKIPLIST_MAXLEVEL	.\redis.h	287;"	d
ZSKIPLIST_P	.\redis.h	288;"	d
_BSD_SOURCE	.\fmacros.h	33;"	d
_FILE_OFFSET_BITS	.\fmacros.h	50;"	d
_GNU_SOURCE	.\fmacros.h	36;"	d
_GNU_SOURCE	.\setproctitle.c	29;"	d	file:
_LARGEFILE_SOURCE	.\fmacros.h	49;"	d
_REDIS_FMACRO_H	.\fmacros.h	31;"	d
_XOPEN_SOURCE	.\fmacros.h	40;"	d
_XOPEN_SOURCE	.\fmacros.h	46;"	d
_ZIPMAP_H	.\zipmap.h	36;"	d
__ADLIST_H__	.\adlist.h	32;"	d
__AE_H__	.\ae.h	34;"	d
__CONFIG_H	.\config.h	31;"	d
__DICT_H	.\dict.h	39;"	d
__ENDIANCONV_H	.\endianconv.h	34;"	d
__INTSET_H	.\intset.h	32;"	d
__PQSORT_H	.\pqsort.h	34;"	d
__REDIS_ASSERT_H__	.\redisassert.h	39;"	d
__REDIS_H	.\redis.h	31;"	d
__REDIS_HELP_H	.\help.h	4;"	d
__REDIS_RDB_H	.\rdb.h	31;"	d
__REDIS_RIO_H	.\rio.h	33;"	d
__REDIS_UTIL_H	.\util.h	31;"	d
__SDS_H	.\sds.h	32;"	d
__TESTHELP_H	.\testhelp.h	40;"	d
__ZMALLOC_H	.\zmalloc.h	32;"	d
__failed_tests	.\testhelp.h	/^int __failed_tests = 0;$/;"	v
__str	.\zmalloc.h	36;"	d
__test_num	.\testhelp.h	/^int __test_num = 0;$/;"	v
__xstr	.\zmalloc.h	35;"	d
__ziplistCascadeUpdate	.\ziplist.c	/^static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {$/;"	f	file:
__ziplistDelete	.\ziplist.c	/^static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {$/;"	f	file:
__ziplistInsert	.\ziplist.c	/^static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	file:
_addReplyObjectToList	.\networking.c	/^void _addReplyObjectToList(redisClient *c, robj *o) {$/;"	f
_addReplySdsToList	.\networking.c	/^void _addReplySdsToList(redisClient *c, sds s) {$/;"	f
_addReplyStringToList	.\networking.c	/^void _addReplyStringToList(redisClient *c, char *s, size_t len) {$/;"	f
_addReplyToBuffer	.\networking.c	/^int _addReplyToBuffer(redisClient *c, char *s, size_t len) {$/;"	f
_anetTcpServer	.\anet.c	/^static int _anetTcpServer(char *err, int port, char *bindaddr, int af)$/;"	f	file:
_assert	.\intset.c	/^void _assert(char *estr, char *file, int line) {$/;"	f
_buf	.\t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	struct:__anon24	file:
_client	.\redis-benchmark.c	/^typedef struct _client {$/;"	s	file:
_dictClear	.\dict.c	/^int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {$/;"	f
_dictExpandIfNeeded	.\dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	file:
_dictInit	.\dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f
_dictKeyIndex	.\dict.c	/^static int _dictKeyIndex(dict *d, const void *key)$/;"	f	file:
_dictNextPower	.\dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	file:
_dictRehashStep	.\dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	file:
_dictReset	.\dict.c	/^static void _dictReset(dictht *ht)$/;"	f	file:
_intsetGet	.\intset.c	/^static int64_t _intsetGet(intset *is, int pos) {$/;"	f	file:
_intsetGetEncoded	.\intset.c	/^static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {$/;"	f	file:
_intsetSet	.\intset.c	/^static void _intsetSet(intset *is, int pos, int64_t value) {$/;"	f	file:
_intsetValueEncoding	.\intset.c	/^static uint8_t _intsetValueEncoding(int64_t v) {$/;"	f	file:
_iterset	.\t_zset.c	/^        union _iterset {$/;"	u	union:__anon18::__anon19	file:
_iterzset	.\t_zset.c	/^        union _iterzset {$/;"	u	union:__anon18::__anon19	file:
_pqsort	.\pqsort.c	/^_pqsort(void *a, size_t n, size_t es,$/;"	f	file:
_redisAssert	.\debug.c	/^void _redisAssert(char *estr, char *file, int line) {$/;"	f
_redisAssertPrintClientInfo	.\debug.c	/^void _redisAssertPrintClientInfo(redisClient *c) {$/;"	f
_redisAssertPrintObject	.\debug.c	/^void _redisAssertPrintObject(robj *o) {$/;"	f
_redisAssertWithInfo	.\debug.c	/^void _redisAssertWithInfo(redisClient *c, robj *o, char *estr, char *file, int line) {$/;"	f
_redisPanic	.\debug.c	/^void _redisPanic(char *msg, char *file, int line) {$/;"	f
_redisSortObject	.\redis.h	/^typedef struct _redisSortObject {$/;"	s
_redisSortOperation	.\redis.h	/^typedef struct _redisSortOperation {$/;"	s
_rfds	.\ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_rio	.\rio.h	/^struct _rio {$/;"	s
_wfds	.\ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
a	.\rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
acceptCommonHandler	.\networking.c	/^static void acceptCommonHandler(int fd, int flags) {$/;"	f	file:
acceptTcpHandler	.\networking.c	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
acceptUnixHandler	.\networking.c	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
activeExpireCycle	.\redis.c	/^void activeExpireCycle(int type) {$/;"	f
activeExpireCycleTryExpire	.\redis.c	/^int activeExpireCycleTryExpire(redisDb *db, struct dictEntry *de, long long now) {$/;"	f
active_expire_enabled	.\redis.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	struct:redisServer
activerehashing	.\redis.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	struct:redisServer
addDeferredMultiBulkLength	.\networking.c	/^void *addDeferredMultiBulkLength(redisClient *c) {$/;"	f
addHashFieldToReply	.\t_hash.c	/^static void addHashFieldToReply(redisClient *c, robj *o, robj *field) {$/;"	f	file:
addHashIteratorCursorToReply	.\t_hash.c	/^static void addHashIteratorCursorToReply(redisClient *c, hashTypeIterator *hi, int what) {$/;"	f	file:
addReply	.\networking.c	/^void addReply(redisClient *c, robj *obj) {$/;"	f
addReplyBulk	.\networking.c	/^void addReplyBulk(redisClient *c, robj *obj) {$/;"	f
addReplyBulkCBuffer	.\networking.c	/^void addReplyBulkCBuffer(redisClient *c, void *p, size_t len) {$/;"	f
addReplyBulkCString	.\networking.c	/^void addReplyBulkCString(redisClient *c, char *s) {$/;"	f
addReplyBulkLen	.\networking.c	/^void addReplyBulkLen(redisClient *c, robj *obj) {$/;"	f
addReplyBulkLongLong	.\networking.c	/^void addReplyBulkLongLong(redisClient *c, long long ll) {$/;"	f
addReplyDictOfRedisInstances	.\sentinel.c	/^void addReplyDictOfRedisInstances(redisClient *c, dict *instances) {$/;"	f
addReplyDouble	.\networking.c	/^void addReplyDouble(redisClient *c, double d) {$/;"	f
addReplyError	.\networking.c	/^void addReplyError(redisClient *c, char *err) {$/;"	f
addReplyErrorFormat	.\networking.c	/^void addReplyErrorFormat(redisClient *c, const char *fmt, ...) {$/;"	f
addReplyErrorLength	.\networking.c	/^void addReplyErrorLength(redisClient *c, char *s, size_t len) {$/;"	f
addReplyLongLong	.\networking.c	/^void addReplyLongLong(redisClient *c, long long ll) {$/;"	f
addReplyLongLongWithPrefix	.\networking.c	/^void addReplyLongLongWithPrefix(redisClient *c, long long ll, char prefix) {$/;"	f
addReplyMultiBulkLen	.\networking.c	/^void addReplyMultiBulkLen(redisClient *c, long length) {$/;"	f
addReplyReplicationBacklog	.\replication.c	/^long long addReplyReplicationBacklog(redisClient *c, long long offset) {$/;"	f
addReplySds	.\networking.c	/^void addReplySds(redisClient *c, sds s) {$/;"	f
addReplySentinelRedisInstance	.\sentinel.c	/^void addReplySentinelRedisInstance(redisClient *c, sentinelRedisInstance *ri) {$/;"	f
addReplyStatus	.\networking.c	/^void addReplyStatus(redisClient *c, char *status) {$/;"	f
addReplyStatusFormat	.\networking.c	/^void addReplyStatusFormat(redisClient *c, const char *fmt, ...) {$/;"	f
addReplyStatusLength	.\networking.c	/^void addReplyStatusLength(redisClient *c, char *s, size_t len) {$/;"	f
addReplyString	.\networking.c	/^void addReplyString(redisClient *c, char *s, size_t len) {$/;"	f
addr	.\sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	struct:sentinelRedisInstance	file:
adjustOpenFilesLimit	.\redis.c	/^void adjustOpenFilesLimit(void) {$/;"	f
aeAddMillisecondsToNow	.\ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	.\ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	.\ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	.\ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	.\ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAssociate	.\ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	file:
aeApiCreate	.\ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	.\ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	.\ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	.\ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	.\ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	.\ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	.\ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	.\ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	.\ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	.\ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	.\ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	.\ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiLookupPending	.\ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	file:
aeApiName	.\ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	.\ae_evport.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	.\ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	.\ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	.\ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	.\ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	.\ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	.\ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiResize	.\ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	.\ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	.\ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	.\ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiState	.\ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	.\ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	.\ae_evport.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	.\ae_evport.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	.\ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	.\ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	.\ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	.\ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	.\ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	.\ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f
aeCreateFileEvent	.\ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	.\ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	.\ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	.\ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	.\ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	.\ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	.\ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	.\ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	.\ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	.\ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	.\ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	.\ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	.\ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	.\ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetFileEvents	.\ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f
aeGetSetSize	.\ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f
aeGetTime	.\ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	.\ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	.\ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeResizeSetSize	.\ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f
aeSearchNearestTimer	.\ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	.\ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeStop	.\ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	.\ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	.\ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	.\ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	.\ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
alsoPropagate	.\redis.c	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
also_propagate	.\redis.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	struct:redisServer
anetCreateSocket	.\anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	file:
anetDisableTcpNoDelay	.\anet.c	/^int anetDisableTcpNoDelay(char *err, int fd) $/;"	f
anetEnableTcpNoDelay	.\anet.c	/^int anetEnableTcpNoDelay(char *err, int fd)$/;"	f
anetGenericAccept	.\anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	file:
anetKeepAlive	.\anet.c	/^int anetKeepAlive(char *err, int fd, int interval)$/;"	f
anetListen	.\anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len) {$/;"	f	file:
anetNonBlock	.\anet.c	/^int anetNonBlock(char *err, int fd)$/;"	f
anetPeerToString	.\anet.c	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {$/;"	f
anetRead	.\anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f
anetResolve	.\anet.c	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len)$/;"	f
anetSetError	.\anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetReuseAddr	.\anet.c	/^static int anetSetReuseAddr(char *err, int fd) {$/;"	f	file:
anetSetSendBuffer	.\anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f
anetSetTcpNoDelay	.\anet.c	/^static int anetSetTcpNoDelay(char *err, int fd, int val)$/;"	f	file:
anetSockName	.\anet.c	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port) {$/;"	f
anetTcp6Server	.\anet.c	/^int anetTcp6Server(char *err, int port, char *bindaddr)$/;"	f
anetTcpAccept	.\anet.c	/^int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {$/;"	f
anetTcpConnect	.\anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f
anetTcpGenericConnect	.\anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)$/;"	f	file:
anetTcpKeepAlive	.\anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f
anetTcpNonBlockConnect	.\anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f
anetTcpServer	.\anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr)$/;"	f
anetUnixAccept	.\anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f
anetUnixConnect	.\anet.c	/^int anetUnixConnect(char *err, char *path)$/;"	f
anetUnixGenericConnect	.\anet.c	/^int anetUnixGenericConnect(char *err, char *path, int flags)$/;"	f
anetUnixNonBlockConnect	.\anet.c	/^int anetUnixNonBlockConnect(char *err, char *path)$/;"	f
anetUnixServer	.\anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm)$/;"	f
anetV6Only	.\anet.c	/^static int anetV6Only(char *err, int s) {$/;"	f	file:
anetWrite	.\anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f
aofRemoveTempFile	.\aof.c	/^void aofRemoveTempFile(pid_t childpid) {$/;"	f
aofRewriteBufferAppend	.\aof.c	/^void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {$/;"	f
aofRewriteBufferReset	.\aof.c	/^void aofRewriteBufferReset(void) {$/;"	f
aofRewriteBufferSize	.\aof.c	/^unsigned long aofRewriteBufferSize(void) {$/;"	f
aofRewriteBufferWrite	.\aof.c	/^ssize_t aofRewriteBufferWrite(int fd) {$/;"	f
aofUpdateCurrentSize	.\aof.c	/^void aofUpdateCurrentSize(void) {$/;"	f
aof_background_fsync	.\aof.c	/^void aof_background_fsync(int fd) {$/;"	f
aof_buf	.\redis.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:redisServer
aof_child_pid	.\redis.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	struct:redisServer
aof_current_size	.\redis.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	struct:redisServer
aof_delayed_fsync	.\redis.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	struct:redisServer
aof_fd	.\redis.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	struct:redisServer
aof_filename	.\redis.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	struct:redisServer
aof_flush_postponed_start	.\redis.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	struct:redisServer
aof_fsync	.\config.h	81;"	d
aof_fsync	.\config.h	83;"	d
aof_fsync	.\redis.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	struct:redisServer
aof_last_fsync	.\redis.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	struct:redisServer
aof_lastbgrewrite_status	.\redis.h	/^    int aof_lastbgrewrite_status;   \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer
aof_no_fsync_on_rewrite	.\redis.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	struct:redisServer
aof_rewrite_base_size	.\redis.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	struct:redisServer
aof_rewrite_buf_blocks	.\redis.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	struct:redisServer
aof_rewrite_incremental_fsync	.\redis.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	struct:redisServer
aof_rewrite_min_size	.\redis.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	struct:redisServer
aof_rewrite_perc	.\redis.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	struct:redisServer
aof_rewrite_scheduled	.\redis.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	struct:redisServer
aof_rewrite_time_last	.\redis.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	struct:redisServer
aof_rewrite_time_start	.\redis.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	struct:redisServer
aof_selected_db	.\redis.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	struct:redisServer
aof_state	.\redis.h	/^    int aof_state;                  \/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	struct:redisServer
aofrwblock	.\aof.c	/^typedef struct aofrwblock {$/;"	s	file:
aofrwblock	.\aof.c	/^} aofrwblock;$/;"	t	typeref:struct:aofrwblock	file:
apidata	.\ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
appendCommand	.\t_string.c	/^void appendCommand(redisClient *c) {$/;"	f
appendServerSaveParams	.\config.c	/^void appendServerSaveParams(time_t seconds, int changes) {$/;"	f
arch_bits	.\redis.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	struct:redisServer
arg0	.\setproctitle.c	/^	const char *arg0;$/;"	m	struct:__anon16	file:
arg1	.\bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:
arg2	.\bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:
arg3	.\bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:
argc	.\redis-cli.c	/^    int argc;$/;"	m	struct:__anon6	file:
argc	.\redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
argc	.\redis.h	/^    int argc;$/;"	m	struct:multiCmd
argc	.\redis.h	/^    int argc;$/;"	m	struct:redisClient
argc	.\slowlog.h	/^    int argc;$/;"	m	struct:slowlogEntry
argv	.\redis-cli.c	/^    sds *argv;$/;"	m	struct:__anon6	file:
argv	.\redis.h	/^    robj **argv;$/;"	m	struct:multiCmd
argv	.\redis.h	/^    robj **argv;$/;"	m	struct:redisClient
argv	.\redis.h	/^    robj **argv;$/;"	m	struct:redisOp
argv	.\sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	struct:sentinelScriptJob	file:
argv	.\slowlog.h	/^    robj **argv;$/;"	m	struct:slowlogEntry
arity	.\redis.h	/^    int arity;$/;"	m	struct:redisCommand
ascii_logo	.\asciilogo.h	/^char *ascii_logo =$/;"	v
assert	.\intset.c	310;"	d	file:
assert	.\redisassert.h	43;"	d
assert_failed	.\redis.h	/^    char *assert_failed;$/;"	m	struct:redisServer
assert_file	.\redis.h	/^    char *assert_file;$/;"	m	struct:redisServer
assert_line	.\redis.h	/^    int assert_line;$/;"	m	struct:redisServer
asyncCloseClientOnOutputBufferLimitReached	.\networking.c	/^void asyncCloseClientOnOutputBufferLimitReached(redisClient *c) {$/;"	f
auth	.\redis-cli.c	/^    char *auth;$/;"	m	struct:config	file:
authCommand	.\redis.c	/^void authCommand(redisClient *c) {$/;"	f
auth_pass	.\sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & slaves. *\/$/;"	m	struct:sentinelRedisInstance	file:
authenticated	.\redis.h	/^    int authenticated;      \/* when requirepass is non-NULL *\/$/;"	m	struct:redisClient
autosync	.\rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	struct:_rio::__anon13::__anon15
avg_ttl	.\redis.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	struct:redisDb
backgroundRewriteDoneHandler	.\aof.c	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal) {$/;"	f
backgroundSaveDoneHandler	.\rdb.c	/^void backgroundSaveDoneHandler(int exitcode, int bysignal) {$/;"	f
backward	.\redis.h	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode
base	.\setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon16	file:
beforeSleep	.\redis.c	/^void beforeSleep(struct aeEventLoop *eventLoop) {$/;"	f
beforesleep	.\ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
benchmark	.\redis-benchmark.c	/^static void benchmark(char *title, char *cmd, int len) {$/;"	f	file:
bgrewriteaofCommand	.\aof.c	/^void bgrewriteaofCommand(redisClient *c) {$/;"	f
bgsaveCommand	.\rdb.c	/^void bgsaveCommand(redisClient *c) {$/;"	f
bgsaveerr	.\redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
bigkeys	.\redis-cli.c	/^    int bigkeys;$/;"	m	struct:config	file:
bindaddr	.\redis.h	/^    char *bindaddr[REDIS_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	struct:redisServer
bindaddr_count	.\redis.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	struct:redisServer
bioCreateBackgroundJob	.\bio.c	/^void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {$/;"	f
bioInit	.\bio.c	/^void bioInit(void) {$/;"	f
bioKillThreads	.\bio.c	/^void bioKillThreads(void) {$/;"	f
bioPendingJobsOfType	.\bio.c	/^unsigned long long bioPendingJobsOfType(int type) {$/;"	f
bioProcessBackgroundJobs	.\bio.c	/^void *bioProcessBackgroundJobs(void *arg) {$/;"	f
bio_condvar	.\bio.c	/^static pthread_cond_t bio_condvar[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_job	.\bio.c	/^struct bio_job {$/;"	s	file:
bio_jobs	.\bio.c	/^static list *bio_jobs[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_mutex	.\bio.c	/^static pthread_mutex_t bio_mutex[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_pending	.\bio.c	/^static unsigned long long bio_pending[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_threads	.\bio.c	/^static pthread_t bio_threads[REDIS_BIO_NUM_OPS];$/;"	v	file:
bitcountCommand	.\bitops.c	/^void bitcountCommand(redisClient *c) {$/;"	f
bitopCommand	.\bitops.c	/^void bitopCommand(redisClient *c) {$/;"	f
blk	.\sha1.c	45;"	d	file:
blk0	.\sha1.c	38;"	d	file:
blk0	.\sha1.c	41;"	d	file:
blockForKeys	.\t_list.c	/^void blockForKeys(redisClient *c, robj **keys, int numkeys, time_t timeout, robj *target) {$/;"	f
blockingPopGenericCommand	.\t_list.c	/^void blockingPopGenericCommand(redisClient *c, int where) {$/;"	f
blockingState	.\redis.h	/^typedef struct blockingState {$/;"	s
blockingState	.\redis.h	/^} blockingState;$/;"	t	typeref:struct:blockingState
blocking_keys	.\redis.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP) *\/$/;"	m	struct:redisDb
blpopCommand	.\t_list.c	/^void blpopCommand(redisClient *c) {$/;"	f
bpop	.\redis.h	/^    blockingState bpop;   \/* blocking state *\/$/;"	m	struct:redisClient
bpop_blocked_clients	.\redis.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	struct:redisServer
brpopCommand	.\t_list.c	/^void brpopCommand(redisClient *c) {$/;"	f
brpoplpushCommand	.\t_list.c	/^void brpoplpushCommand(redisClient *c) {$/;"	f
buf	.\aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	struct:aofrwblock	file:
buf	.\redis.h	/^    char buf[REDIS_REPLY_CHUNK_BYTES];$/;"	m	struct:redisClient
buf	.\sds.h	/^    char buf[];$/;"	m	struct:sdshdr
buffer	.\rio.h	/^        } buffer;$/;"	m	union:_rio::__anon13	typeref:struct:_rio::__anon13::__anon14
buffer	.\sha1.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon17
buffered	.\rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	struct:_rio::__anon13::__anon15
bufpos	.\redis.h	/^    int bufpos;$/;"	m	struct:redisClient
bugReportStart	.\debug.c	/^void bugReportStart(void) {$/;"	f
bug_report_start	.\redis.h	/^    int bug_report_start; \/* True if bug report header was already logged. *\/$/;"	m	struct:redisServer
bulkhdr	.\redis.h	/^    *bulkhdr[REDIS_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
bulklen	.\redis.h	/^    long bulklen;           \/* length of bulk argument in multi bulk request *\/$/;"	m	struct:redisClient
bytesToHuman	.\redis-cli.c	/^void bytesToHuman(char *s, long long n) {$/;"	f
bytesToHuman	.\redis.c	/^void bytesToHuman(char *s, unsigned long long n) {$/;"	f
c	.\rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
cached_master	.\redis.h	/^    redisClient *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	struct:redisServer
call	.\redis.c	/^void call(redisClient *c, int flags) {$/;"	f
calloc	.\zmalloc.c	60;"	d	file:
calloc	.\zmalloc.c	65;"	d	file:
calls	.\redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand
cancelReplicationHandshake	.\replication.c	/^int cancelReplicationHandshake(void) {$/;"	f
catAppendOnlyExpireAtCommand	.\aof.c	/^sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {$/;"	f
catAppendOnlyGenericCommand	.\aof.c	/^sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {$/;"	f
cc	.\sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	struct:sentinelRedisInstance	file:
cc_conn_time	.\sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:
changes	.\redis.h	/^    int changes;$/;"	m	struct:saveparam
checkClientOutputBufferLimits	.\networking.c	/^int checkClientOutputBufferLimits(redisClient *c) {$/;"	f
checkConsistency	.\intset.c	/^void checkConsistency(intset *is) {$/;"	f
checkForSentinelMode	.\redis.c	/^int checkForSentinelMode(int argc, char **argv) {$/;"	f
checkStringLength	.\t_string.c	/^static int checkStringLength(redisClient *c, long long size) {$/;"	f	file:
checkType	.\object.c	/^int checkType(redisClient *c, robj *o, int type) {$/;"	f
checkType	.\redis-check-dump.c	/^int checkType(unsigned char t) {$/;"	f
cksum	.\rio.h	/^    uint64_t cksum;$/;"	m	struct:_rio
cliAuth	.\redis-cli.c	/^static int cliAuth() {$/;"	f	file:
cliConnect	.\redis-cli.c	/^static int cliConnect(int force) {$/;"	f	file:
cliFormatReplyCSV	.\redis-cli.c	/^static sds cliFormatReplyCSV(redisReply *r) {$/;"	f	file:
cliFormatReplyRaw	.\redis-cli.c	/^static sds cliFormatReplyRaw(redisReply *r) {$/;"	f	file:
cliFormatReplyTTY	.\redis-cli.c	/^static sds cliFormatReplyTTY(redisReply *r, char *prefix) {$/;"	f	file:
cliInitHelp	.\redis-cli.c	/^static void cliInitHelp() {$/;"	f	file:
cliOutputCommandHelp	.\redis-cli.c	/^static void cliOutputCommandHelp(struct commandHelp *help, int group) {$/;"	f	file:
cliOutputGenericHelp	.\redis-cli.c	/^static void cliOutputGenericHelp() {$/;"	f	file:
cliOutputHelp	.\redis-cli.c	/^static void cliOutputHelp(int argc, char **argv) {$/;"	f	file:
cliPrintContextError	.\redis-cli.c	/^static void cliPrintContextError() {$/;"	f	file:
cliReadReply	.\redis-cli.c	/^static int cliReadReply(int output_raw_strings) {$/;"	f	file:
cliRefreshPrompt	.\redis-cli.c	/^static void cliRefreshPrompt(void) {$/;"	f	file:
cliSelect	.\redis-cli.c	/^static int cliSelect() {$/;"	f	file:
cliSendCommand	.\redis-cli.c	/^static int cliSendCommand(int argc, char **argv, int repeat) {$/;"	f	file:
cliVersion	.\redis-cli.c	/^static sds cliVersion() {$/;"	f	file:
client	.\redis-benchmark.c	/^} *client;$/;"	t	typeref:struct:_client	file:
client	.\redis.h	/^    redisClient *client;$/;"	m	struct:pubsubPattern
clientBufferLimitsConfig	.\redis.h	/^typedef struct clientBufferLimitsConfig {$/;"	s
clientBufferLimitsConfig	.\redis.h	/^} clientBufferLimitsConfig;$/;"	t	typeref:struct:clientBufferLimitsConfig
clientBufferLimitsDefaults	.\config.c	/^clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_LIMIT_NUM_CLASSES] = {$/;"	v
clientCommand	.\networking.c	/^void clientCommand(redisClient *c) {$/;"	f
clientData	.\ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	.\ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clientDone	.\redis-benchmark.c	/^static void clientDone(client c) {$/;"	f	file:
client_max_querybuf_len	.\redis.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	struct:redisServer
client_obuf_limits	.\redis.h	/^    clientBufferLimitsConfig client_obuf_limits[REDIS_CLIENT_LIMIT_NUM_CLASSES];$/;"	m	struct:redisServer
client_reconfig_script	.\sentinel.c	/^    char *client_reconfig_script;$/;"	m	struct:sentinelRedisInstance	file:
clients	.\redis-benchmark.c	/^    list *clients;$/;"	m	struct:config	file:
clients	.\redis.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	struct:redisServer
clientsCron	.\redis.c	/^void clientsCron(void) {$/;"	f
clientsCronHandleTimeout	.\redis.c	/^int clientsCronHandleTimeout(redisClient *c) {$/;"	f
clientsCronResizeQueryBuffer	.\redis.c	/^int clientsCronResizeQueryBuffer(redisClient *c) {$/;"	f
clients_to_close	.\redis.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	struct:redisServer
closeListeningSockets	.\redis.c	/^void closeListeningSockets(int unlink_unix_socket) {$/;"	f
cluster_mode	.\redis-cli.c	/^    int cluster_mode;$/;"	m	struct:config	file:
cluster_reissue_command	.\redis-cli.c	/^    int cluster_reissue_command;$/;"	m	struct:config	file:
cmd	.\redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::redisCommand
cmd	.\redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand
cmd	.\redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:redisOp	typeref:struct:redisOp::redisCommand
cmpobj	.\redis.h	/^        robj *cmpobj;$/;"	m	union:_redisSortObject::__anon7
cnegone	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
collateStringObjects	.\object.c	/^int collateStringObjects(robj *a, robj *b) {$/;"	f
colon	.\redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
commandGroups	.\help.h	/^static char *commandGroups[] = {$/;"	v
commandHelp	.\help.h	/^struct commandHelp {$/;"	s
commandHelp	.\help.h	/^} commandHelp[] = {$/;"	v	typeref:struct:commandHelp
commandTable	.\redis.c	/^struct redisCommand *commandTable;$/;"	v	typeref:struct:redisCommand
commandTableDictType	.\redis.c	/^dictType commandTableDictType = {$/;"	v
commands	.\redis.h	/^    dict *commands;             \/* Command table *\/$/;"	m	struct:redisServer
commands	.\redis.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState
compareLatency	.\redis-benchmark.c	/^static int compareLatency(const void *a, const void *b) {$/;"	f	file:
compareSlavesForPromotion	.\sentinel.c	/^int compareSlavesForPromotion(const void *a, const void *b) {$/;"	f
compareStringObjects	.\object.c	/^int compareStringObjects(robj *a, robj *b) {$/;"	f
compareStringObjectsWithFlags	.\object.c	/^int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {$/;"	f
completionCallback	.\redis-cli.c	/^static void completionCallback(const char *buf, linenoiseCompletions *lc) {$/;"	f	file:
computeDatasetDigest	.\debug.c	/^void computeDatasetDigest(unsigned char *final) {$/;"	f
cone	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
config	.\redis-benchmark.c	/^static struct config {$/;"	s	file:
config	.\redis-benchmark.c	/^} config;$/;"	v	typeref:struct:config	file:
config	.\redis-cli.c	/^static struct config {$/;"	s	file:
config	.\redis-cli.c	/^} config;$/;"	v	typeref:struct:config	file:
configCommand	.\config.c	/^void configCommand(redisClient *c) {$/;"	f
configGetCommand	.\config.c	/^void configGetCommand(redisClient *c) {$/;"	f
configSetCommand	.\config.c	/^void configSetCommand(redisClient *c) {$/;"	f
config_epoch	.\sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	struct:sentinelRedisInstance	file:
config_get_bool_field	.\config.c	888;"	d	file:
config_get_numerical_field	.\config.c	896;"	d	file:
config_get_string_field	.\config.c	880;"	d	file:
configfile	.\redis.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	struct:redisServer
connectWithMaster	.\replication.c	/^int connectWithMaster(void) {$/;"	f
consumeNewline	.\redis-check-aof.c	/^int consumeNewline(char *buf) {$/;"	f
contents	.\intset.h	/^    int8_t contents[];$/;"	m	struct:intset
context	.\redis-benchmark.c	/^    redisContext *context;$/;"	m	struct:_client	file:
context	.\redis-cli.c	/^static redisContext *context;$/;"	v	file:
context	.\sentinel.c	/^    redisAsyncContext *context;$/;"	m	struct:redisAeEvents	file:
convertToSds	.\redis-cli.c	/^static char **convertToSds(int count, char** args) {$/;"	f	file:
copyClientOutputBuffer	.\networking.c	/^void copyClientOutputBuffer(redisClient *dst, redisClient *src) {$/;"	f
count	.\redis.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState
count	.\sha1.h	/^    u_int32_t count[2];$/;"	m	struct:__anon17
crc64	.\crc64.c	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {$/;"	f
crc64_tab	.\crc64.c	/^static const uint64_t crc64_tab[256] = {$/;"	v	file:
createClient	.\networking.c	/^redisClient *createClient(int fd) {$/;"	f
createClient	.\redis-benchmark.c	/^static client createClient(char *cmd, size_t len, client from) {$/;"	f	file:
createDumpPayload	.\migrate.c	/^void createDumpPayload(rio *payload, robj *o) {$/;"	f
createFakeClient	.\aof.c	/^struct redisClient *createFakeClient(void) {$/;"	f
createHashObject	.\object.c	/^robj *createHashObject(void) {$/;"	f
createIntList	.\ziplist.c	/^unsigned char *createIntList() {$/;"	f
createIntsetObject	.\object.c	/^robj *createIntsetObject(void) {$/;"	f
createList	.\ziplist.c	/^unsigned char *createList() {$/;"	f
createListObject	.\object.c	/^robj *createListObject(void) {$/;"	f
createMissingClients	.\redis-benchmark.c	/^static void createMissingClients(client c) {$/;"	f	file:
createObject	.\object.c	/^robj *createObject(int type, void *ptr) {$/;"	f
createPidFile	.\redis.c	/^void createPidFile(void) {$/;"	f
createReplicationBacklog	.\replication.c	/^void createReplicationBacklog(void) {$/;"	f
createSentinelAddr	.\sentinel.c	/^sentinelAddr *createSentinelAddr(char *hostname, int port) {$/;"	f
createSentinelRedisInstance	.\sentinel.c	/^sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {$/;"	f
createSet	.\intset.c	/^intset *createSet(int bits, int size) {$/;"	f
createSetObject	.\object.c	/^robj *createSetObject(void) {$/;"	f
createSharedObjects	.\redis.c	/^void createSharedObjects(void) {$/;"	f
createSortOperation	.\sort.c	/^redisSortOperation *createSortOperation(int type, robj *pattern) {$/;"	f
createStringObject	.\object.c	/^robj *createStringObject(char *ptr, size_t len) {$/;"	f
createStringObjectFromLongDouble	.\object.c	/^robj *createStringObjectFromLongDouble(long double value) {$/;"	f
createStringObjectFromLongLong	.\object.c	/^robj *createStringObjectFromLongLong(long long value) {$/;"	f
createZiplistObject	.\object.c	/^robj *createZiplistObject(void) {$/;"	f
createZsetObject	.\object.c	/^robj *createZsetObject(void) {$/;"	f
createZsetZiplistObject	.\object.c	/^robj *createZsetZiplistObject(void) {$/;"	f
crlf	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
cronloops	.\redis.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	struct:redisServer
csv	.\redis-benchmark.c	/^    int csv;$/;"	m	struct:config	file:
ctime	.\redis.h	/^    time_t ctime;           \/* Client creation time *\/$/;"	m	struct:redisClient
current_client	.\redis.h	/^    redisClient *current_client; \/* Current client, only used on crash report *\/$/;"	m	struct:redisServer
current_epoch	.\sentinel.c	/^    uint64_t current_epoch;     \/* Current epoch. *\/$/;"	m	struct:sentinelState	file:
czero	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
d	.\dict.h	/^    dict *d;$/;"	m	struct:dictIterator
d2string	.\util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f
daemonize	.\redis.c	/^void daemonize(void) {$/;"	f
daemonize	.\redis.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	struct:redisServer
data	.\redis-check-dump.c	/^    void *data;$/;"	m	struct:__anon3	file:
databasesCron	.\redis.c	/^void databasesCron(void) {$/;"	f
datasize	.\redis-benchmark.c	/^    int datasize;$/;"	m	struct:config	file:
db	.\multi.c	/^    redisDb *db;$/;"	m	struct:watchedKey	file:
db	.\redis.h	/^    redisDb *db;$/;"	m	struct:readyList
db	.\redis.h	/^    redisDb *db;$/;"	m	struct:redisClient
db	.\redis.h	/^    redisDb *db;$/;"	m	struct:redisServer
dbAdd	.\db.c	/^void dbAdd(redisDb *db, robj *key, robj *val) {$/;"	f
dbDelete	.\db.c	/^int dbDelete(redisDb *db, robj *key) {$/;"	f
dbDictType	.\redis.c	/^dictType dbDictType = {$/;"	v
dbExists	.\db.c	/^int dbExists(redisDb *db, robj *key) {$/;"	f
dbOverwrite	.\db.c	/^void dbOverwrite(redisDb *db, robj *key, robj *val) {$/;"	f
dbRandomKey	.\db.c	/^robj *dbRandomKey(redisDb *db) {$/;"	f
dbid	.\redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
dbnum	.\redis-benchmark.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnum	.\redis-cli.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnum	.\redis.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	struct:redisServer
dbnumstr	.\redis-benchmark.c	/^    sds dbnumstr;$/;"	m	struct:config	file:
dbsizeCommand	.\db.c	/^void dbsizeCommand(redisClient *c) {$/;"	f
de	.\redis.h	/^    dictEntry *de;$/;"	m	struct:__anon11
de	.\t_zset.c	/^                dictEntry *de;$/;"	m	struct:__anon18::__anon19::_iterset::__anon21	file:
debug	.\ziplist.c	959;"	d	file:
debugCommand	.\debug.c	/^void debugCommand(redisClient *c) {$/;"	f
decrCommand	.\t_string.c	/^void decrCommand(redisClient *c) {$/;"	f
decrRefCount	.\object.c	/^void decrRefCount(robj *o) {$/;"	f
decrRefCountVoid	.\object.c	/^void decrRefCountVoid(void *o) {$/;"	f
decrbyCommand	.\t_string.c	/^void decrbyCommand(redisClient *c) {$/;"	f
del	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
delCommand	.\db.c	/^void delCommand(redisClient *c) {$/;"	f
delCommand	.\redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,*rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::redisCommand
di	.\redis.h	/^    dictIterator *di;$/;"	m	struct:__anon10
di	.\redis.h	/^    dictIterator *di;$/;"	m	struct:__anon11
di	.\t_zset.c	/^                dictIterator *di;$/;"	m	struct:__anon18::__anon19::_iterset::__anon21	file:
dict	.\dict.h	/^typedef struct dict {$/;"	s
dict	.\dict.h	/^} dict;$/;"	t	typeref:struct:dict
dict	.\redis.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb
dict	.\redis.h	/^    dict *dict;$/;"	m	struct:zset
dict	.\t_zset.c	/^                dict *dict;$/;"	m	struct:__anon18::__anon19::_iterset::__anon21	file:
dictAdd	.\dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f
dictAddRaw	.\dict.c	/^dictEntry *dictAddRaw(dict *d, void *key)$/;"	f
dictCompareKeys	.\dict.h	137;"	d
dictCreate	.\dict.c	/^dict *dictCreate(dictType *type,$/;"	f
dictDelete	.\dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f
dictDeleteNoFree	.\dict.c	/^int dictDeleteNoFree(dict *ht, const void *key) {$/;"	f
dictDisableResize	.\dict.c	/^void dictDisableResize(void) {$/;"	f
dictEmpty	.\dict.c	/^void dictEmpty(dict *d, void(callback)(void*)) {$/;"	f
dictEnableResize	.\dict.c	/^void dictEnableResize(void) {$/;"	f
dictEncObjHash	.\redis.c	/^unsigned int dictEncObjHash(const void *key) {$/;"	f
dictEncObjKeyCompare	.\redis.c	/^int dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictEntry	.\dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	.\dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictExpand	.\dict.c	/^int dictExpand(dict *d, unsigned long size)$/;"	f
dictFetchValue	.\dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f
dictFind	.\dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f
dictFingerprint	.\dict.c	/^long long dictFingerprint(dict *d) {$/;"	f
dictFreeKey	.\dict.h	126;"	d
dictFreeVal	.\dict.h	109;"	d
dictGenCaseHashFunction	.\dict.c	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {$/;"	f
dictGenHashFunction	.\dict.c	/^unsigned int dictGenHashFunction(const void *key, int len) {$/;"	f
dictGenericDelete	.\dict.c	/^static int dictGenericDelete(dict *d, const void *key, int nofree)$/;"	f	file:
dictGetHashFunctionSeed	.\dict.c	/^uint32_t dictGetHashFunctionSeed(void) {$/;"	f
dictGetIterator	.\dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f
dictGetKey	.\dict.h	143;"	d
dictGetRandomKey	.\dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f
dictGetSafeIterator	.\dict.c	/^dictIterator *dictGetSafeIterator(dict *d) {$/;"	f
dictGetSignedIntegerVal	.\dict.h	145;"	d
dictGetUnsignedIntegerVal	.\dict.h	146;"	d
dictGetVal	.\dict.h	144;"	d
dictHashKey	.\dict.h	142;"	d
dictIdentityHashFunction	.\dict.c	/^unsigned int dictIdentityHashFunction(unsigned int key)$/;"	f
dictInstancesValDestructor	.\sentinel.c	/^void dictInstancesValDestructor (void *privdata, void *obj) {$/;"	f
dictIntHashFunction	.\dict.c	/^unsigned int dictIntHashFunction(unsigned int key)$/;"	f
dictIsRehashing	.\dict.h	149;"	d
dictIterator	.\dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	.\dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictListDestructor	.\redis.c	/^void dictListDestructor(void *privdata, void *val)$/;"	f
dictNext	.\dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f
dictObjHash	.\redis.c	/^unsigned int dictObjHash(const void *key) {$/;"	f
dictObjKeyCompare	.\redis.c	/^int dictObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictRedisObjectDestructor	.\redis.c	/^void dictRedisObjectDestructor(void *privdata, void *val)$/;"	f
dictRehash	.\dict.c	/^int dictRehash(dict *d, int n) {$/;"	f
dictRehashMilliseconds	.\dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f
dictRelease	.\dict.c	/^void dictRelease(dict *d)$/;"	f
dictReleaseIterator	.\dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f
dictReplace	.\dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f
dictReplaceRaw	.\dict.c	/^dictEntry *dictReplaceRaw(dict *d, void *key) {$/;"	f
dictResize	.\dict.c	/^int dictResize(dict *d)$/;"	f
dictScan	.\dict.c	/^unsigned long dictScan(dict *d,$/;"	f
dictScanFunction	.\dict.h	/^typedef void (dictScanFunction)(void *privdata, const dictEntry *de);$/;"	t
dictSdsCaseHash	.\redis.c	/^unsigned int dictSdsCaseHash(const void *key) {$/;"	f
dictSdsDestructor	.\redis.c	/^void dictSdsDestructor(void *privdata, void *val)$/;"	f
dictSdsHash	.\redis.c	/^unsigned int dictSdsHash(const void *key) {$/;"	f
dictSdsKeyCaseCompare	.\redis.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1,$/;"	f
dictSdsKeyCompare	.\redis.c	/^int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f
dictSetHashFunctionSeed	.\dict.c	/^void dictSetHashFunctionSeed(uint32_t seed) {$/;"	f
dictSetKey	.\dict.h	130;"	d
dictSetSignedIntegerVal	.\dict.h	120;"	d
dictSetUnsignedIntegerVal	.\dict.h	123;"	d
dictSetVal	.\dict.h	113;"	d
dictSize	.\dict.h	148;"	d
dictSlots	.\dict.h	147;"	d
dictType	.\dict.h	/^typedef struct dictType {$/;"	s
dictType	.\dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
dictVanillaFree	.\redis.c	/^void dictVanillaFree(void *privdata, void *val)$/;"	f
dict_can_resize	.\dict.c	/^static int dict_can_resize = 1;$/;"	v	file:
dict_force_resize_ratio	.\dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	file:
dict_hash_function_seed	.\dict.c	/^static uint32_t dict_hash_function_seed = 5381;$/;"	v	file:
dictht	.\dict.h	/^typedef struct dictht {$/;"	s
dictht	.\dict.h	/^} dictht;$/;"	t	typeref:struct:dictht
dictid	.\redis.h	/^    int dictid;$/;"	m	struct:redisClient
direction	.\adlist.h	/^    int direction;$/;"	m	struct:listIter
direction	.\redis.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	struct:__anon8
dirty	.\redis.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	struct:redisServer
dirty_before_bgsave	.\redis.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	struct:redisServer
disableWatchdog	.\debug.c	/^void disableWatchdog(void) {$/;"	f
discardCommand	.\multi.c	/^void discardCommand(redisClient *c) {$/;"	f
discardTransaction	.\multi.c	/^void discardTransaction(redisClient *c) {$/;"	f
disconnectSlaves	.\networking.c	/^void disconnectSlaves(void) {$/;"	f
down_after_period	.\sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	struct:sentinelRedisInstance	file:
dumpCommand	.\migrate.c	/^void dumpCommand(redisClient *c) {$/;"	f
dup	.\adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list
dupClientReplyValue	.\networking.c	/^void *dupClientReplyValue(void *o) {$/;"	f
dupLastObjectIfNeeded	.\networking.c	/^robj *dupLastObjectIfNeeded(list *reply) {$/;"	f
dupSentinelAddr	.\sentinel.c	/^sentinelAddr *dupSentinelAddr(sentinelAddr *src) {$/;"	f
dupStringObject	.\object.c	/^robj *dupStringObject(robj *o) {$/;"	f
duration	.\slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	struct:slowlogEntry
echoCommand	.\redis.c	/^void echoCommand(redisClient *c) {$/;"	f
el	.\redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:config	file:
el	.\redis.h	/^    aeEventLoop *el;$/;"	m	struct:redisServer
ele	.\t_zset.c	/^    robj *ele;$/;"	m	struct:__anon24	file:
elen	.\t_zset.c	/^    unsigned int elen;$/;"	m	struct:__anon24	file:
ell	.\t_zset.c	/^    long long ell;$/;"	m	struct:__anon24	file:
emptyDb	.\db.c	/^long long emptyDb(void(callback)(void*)) {$/;"	f
emptybulk	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
emptymultibulk	.\redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
emptyscan	.\redis.h	/^    *lpush, *emptyscan,$/;"	m	struct:sharedObjectsStruct
enableWatchdog	.\debug.c	/^void enableWatchdog(int period) {$/;"	f
encoding	.\intset.h	/^    uint32_t encoding;$/;"	m	struct:intset
encoding	.\redis.h	/^    int encoding;$/;"	m	struct:__anon10
encoding	.\redis.h	/^    int encoding;$/;"	m	struct:__anon11
encoding	.\redis.h	/^    unsigned char encoding;$/;"	m	struct:__anon8
encoding	.\redis.h	/^    unsigned encoding:4;$/;"	m	struct:redisObject
encoding	.\t_zset.c	/^    int encoding;$/;"	m	struct:__anon18	file:
encoding	.\ziplist.c	/^    unsigned char encoding;$/;"	m	struct:zlentry	file:
end	.\setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon16	file:
entry	.\dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
entry	.\redis-check-dump.c	/^} entry;$/;"	t	typeref:struct:__anon5	file:
epfd	.\ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
epos	.\redis-check-aof.c	/^static off_t epos;$/;"	v	file:
eptr	.\t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon18::__anon19::_iterzset::__anon22	file:
equalStringObjects	.\object.c	/^int equalStringObjects(robj *a, robj *b) {$/;"	f
err	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
error	.\intset.c	/^void error(char *err) {$/;"	f
error	.\redis-check-aof.c	/^static char error[1024];$/;"	v	file:
error	.\redis-check-dump.c	/^    char error[16][1024];$/;"	m	struct:__anon4	file:
error	.\setproctitle.c	/^	int error;$/;"	m	struct:__anon16	file:
errors	.\redis-check-dump.c	/^static errors_t errors;$/;"	v	file:
errors_t	.\redis-check-dump.c	/^} errors_t;$/;"	t	typeref:struct:__anon4	file:
estimateObjectIdleTime	.\object.c	/^unsigned long estimateObjectIdleTime(robj *o) {$/;"	f
estr	.\t_zset.c	/^    unsigned char *estr;$/;"	m	struct:__anon24	file:
eval	.\redis-cli.c	/^    char *eval;$/;"	m	struct:config	file:
evalCommand	.\scripting.c	/^void evalCommand(redisClient *c) {$/;"	f
evalGenericCommand	.\scripting.c	/^void evalGenericCommand(redisClient *c, int evalsha) {$/;"	f
evalMode	.\redis-cli.c	/^static int evalMode(int argc, char **argv) {$/;"	f	file:
evalShaCommand	.\scripting.c	/^void evalShaCommand(redisClient *c) {$/;"	f
events	.\ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	.\ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	.\ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
evport_debug	.\ae_evport.c	/^static int evport_debug = 0;$/;"	v	file:
execCommand	.\multi.c	/^void execCommand(redisClient *c) {$/;"	f
execCommandPropagateMulti	.\multi.c	/^void execCommandPropagateMulti(redisClient *c) {$/;"	f
execaborterr	.\redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
existsCommand	.\db.c	/^void existsCommand(redisClient *c) {$/;"	f
exitFromChild	.\redis.c	/^void exitFromChild(int retcode) {$/;"	f
expect	.\lzf_c.c	79;"	d	file:
expect	.\lzf_c.c	82;"	d	file:
expect_false	.\lzf_c.c	86;"	d	file:
expect_true	.\lzf_c.c	87;"	d	file:
expireCommand	.\db.c	/^void expireCommand(redisClient *c) {$/;"	f
expireGenericCommand	.\db.c	/^void expireGenericCommand(redisClient *c, long long basetime, int unit) {$/;"	f
expireIfNeeded	.\db.c	/^int expireIfNeeded(redisDb *db, robj *key) {$/;"	f
expireatCommand	.\db.c	/^void expireatCommand(redisClient *c) {$/;"	f
expires	.\redis.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb
failover_epoch	.\sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_start_time	.\sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_state	.\sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	struct:sentinelRedisInstance	file:
failover_state_change_time	.\sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	struct:sentinelRedisInstance	file:
failover_timeout	.\sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	struct:sentinelRedisInstance	file:
fd	.\ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	.\redis.h	/^    int fd;$/;"	m	struct:redisClient
fd	.\sentinel.c	/^    int fd;$/;"	m	struct:redisAeEvents	file:
feedAppendOnlyFile	.\aof.c	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f
feedReplicationBacklog	.\replication.c	/^void feedReplicationBacklog(void *ptr, size_t len) {$/;"	f
feedReplicationBacklogWithObject	.\replication.c	/^void feedReplicationBacklogWithObject(robj *o) {$/;"	f
file	.\rio.h	/^        } file;$/;"	m	union:_rio::__anon13	typeref:struct:_rio::__anon13::__anon15
finalizerProc	.\ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
findBigKeys	.\redis-cli.c	/^static void findBigKeys(void) {$/;"	f	file:
fingerprint	.\dict.h	/^    long long fingerprint; \/* unsafe iterator fingerprint for misuse detection *\/$/;"	m	struct:dictIterator
fired	.\ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop
firstkey	.\redis.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand
flagTransaction	.\multi.c	/^void flagTransaction(redisClient *c) {$/;"	f
flags	.\redis.h	/^    int flags;              \/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... *\/$/;"	m	struct:redisClient
flags	.\redis.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:redisCommand
flags	.\sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	struct:sentinelScriptJob	file:
flags	.\sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	struct:sentinelRedisInstance	file:
flags	.\t_zset.c	/^    int flags;$/;"	m	struct:__anon24	file:
flushAppendOnlyFile	.\aof.c	/^void flushAppendOnlyFile(int force) {$/;"	f
flushSlavesOutputBuffers	.\networking.c	/^void flushSlavesOutputBuffers(void) {$/;"	f
flushallCommand	.\db.c	/^void flushallCommand(redisClient *c) {$/;"	f
flushdbCommand	.\db.c	/^void flushdbCommand(redisClient *c) {$/;"	f
forceCommandPropagation	.\redis.c	/^void forceCommandPropagation(redisClient *c, int flags) {$/;"	f
formatPeerId	.\networking.c	/^void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port) {$/;"	f
forward	.\redis.h	/^        struct zskiplistNode *forward;$/;"	m	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode
fp	.\rio.h	/^            FILE *fp;$/;"	m	struct:_rio::__anon13::__anon15
fptr	.\redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon11
free	.\adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list
free	.\aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:
free	.\sds.h	/^    int free;$/;"	m	struct:sdshdr
free	.\zmalloc.c	62;"	d	file:
free	.\zmalloc.c	67;"	d	file:
freeAllClients	.\redis-benchmark.c	/^static void freeAllClients(void) {$/;"	f	file:
freeClient	.\networking.c	/^void freeClient(redisClient *c) {$/;"	f
freeClient	.\redis-benchmark.c	/^static void freeClient(client c) {$/;"	f	file:
freeClientArgv	.\networking.c	/^static void freeClientArgv(redisClient *c) {$/;"	f	file:
freeClientAsync	.\networking.c	/^void freeClientAsync(redisClient *c) {$/;"	f
freeClientMultiState	.\multi.c	/^void freeClientMultiState(redisClient *c) {$/;"	f
freeClientsInAsyncFreeQueue	.\networking.c	/^void freeClientsInAsyncFreeQueue(void) {$/;"	f
freeFakeClient	.\aof.c	/^void freeFakeClient(struct redisClient *c) {$/;"	f
freeHashObject	.\object.c	/^void freeHashObject(robj *o) {$/;"	f
freeListObject	.\object.c	/^void freeListObject(robj *o) {$/;"	f
freeMemoryIfNeeded	.\redis.c	/^int freeMemoryIfNeeded(void) {$/;"	f
freePubsubPattern	.\pubsub.c	/^void freePubsubPattern(void *p) {$/;"	f
freeReplicationBacklog	.\replication.c	/^void freeReplicationBacklog(void) {$/;"	f
freeSetObject	.\object.c	/^void freeSetObject(robj *o) {$/;"	f
freeStringObject	.\object.c	/^void freeStringObject(robj *o) {$/;"	f
freeZsetObject	.\object.c	/^void freeZsetObject(robj *o) {$/;"	f
full	.\redis-cli.c	/^    sds full;$/;"	m	struct:__anon6	file:
genRedisInfoString	.\redis.c	/^sds genRedisInfoString(char *section) {$/;"	f
genericHgetallCommand	.\t_hash.c	/^void genericHgetallCommand(redisClient *c, int flags) {$/;"	f
genericZrangebyscoreCommand	.\t_zset.c	/^void genericZrangebyscoreCommand(redisClient *c, int reverse) {$/;"	f
getAbsolutePath	.\util.c	/^sds getAbsolutePath(char *filename) {$/;"	f
getAllClientsInfoString	.\networking.c	/^sds getAllClientsInfoString(void) {$/;"	f
getBitOffsetFromArgument	.\bitops.c	/^static int getBitOffsetFromArgument(redisClient *c, robj *o, size_t *offset) {$/;"	f	file:
getClientInfoString	.\networking.c	/^sds getClientInfoString(redisClient *client) {$/;"	f
getClientLimitClass	.\networking.c	/^int getClientLimitClass(redisClient *c) {$/;"	f
getClientLimitClassByName	.\networking.c	/^int getClientLimitClassByName(char *name) {$/;"	f
getClientLimitClassName	.\networking.c	/^char *getClientLimitClassName(int class) {$/;"	f
getClientOutputBufferMemoryUsage	.\networking.c	/^unsigned long getClientOutputBufferMemoryUsage(redisClient *c) {$/;"	f
getClientPeerId	.\networking.c	/^int getClientPeerId(redisClient *client, char *peerid, size_t peerid_len) {$/;"	f
getClientsMaxBuffers	.\networking.c	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	f
getCommand	.\t_string.c	/^void getCommand(redisClient *c) {$/;"	f
getDecodedObject	.\object.c	/^robj *getDecodedObject(robj *o) {$/;"	f
getDoubleFromObject	.\object.c	/^int getDoubleFromObject(robj *o, double *target) {$/;"	f
getDoubleFromObjectOrReply	.\object.c	/^int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg) {$/;"	f
getExpire	.\db.c	/^long long getExpire(redisDb *db, robj *key) {$/;"	f
getGenericCommand	.\t_string.c	/^int getGenericCommand(redisClient *c) {$/;"	f
getInfoField	.\redis-cli.c	/^static char *getInfoField(char *info, char *field) {$/;"	f	file:
getKeysFreeResult	.\db.c	/^void getKeysFreeResult(int *result) {$/;"	f
getKeysFromCommand	.\db.c	/^int *getKeysFromCommand(struct redisCommand *cmd,robj **argv, int argc, int *numkeys, int flags) {$/;"	f
getKeysUsingCommandTable	.\db.c	/^int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {$/;"	f
getLongDoubleFromObject	.\object.c	/^int getLongDoubleFromObject(robj *o, long double *target) {$/;"	f
getLongDoubleFromObjectOrReply	.\object.c	/^int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg) {$/;"	f
getLongFromObjectOrReply	.\object.c	/^int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg) {$/;"	f
getLongInfoField	.\redis-cli.c	/^static long getLongInfoField(char *info, char *field) {$/;"	f	file:
getLongLongFromObject	.\object.c	/^int getLongLongFromObject(robj *o, long long *target) {$/;"	f
getLongLongFromObjectOrReply	.\object.c	/^int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg) {$/;"	f
getMcontextEip	.\debug.c	/^static void *getMcontextEip(ucontext_t *uc) {$/;"	f	file:
getOperationsPerSecond	.\redis.c	/^long long getOperationsPerSecond(void) {$/;"	f
getRDB	.\redis-cli.c	/^static void getRDB(void) {$/;"	f	file:
getRandomHexChars	.\util.c	/^void getRandomHexChars(char *p, unsigned int len) {$/;"	f
getSentinelRedisInstanceByAddrAndRunID	.\sentinel.c	/^sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {$/;"	f
getTimeoutFromObjectOrReply	.\t_list.c	/^int getTimeoutFromObjectOrReply(redisClient *c, robj *object, time_t *timeout) {$/;"	f
getbitCommand	.\bitops.c	/^void getbitCommand(redisClient *c) {$/;"	f
getkeys_proc	.\redis.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	struct:redisCommand
getrangeCommand	.\t_string.c	/^void getrangeCommand(redisClient *c) {$/;"	f
getrdb_mode	.\redis-cli.c	/^    int getrdb_mode;$/;"	m	struct:config	file:
getsetCommand	.\t_string.c	/^void getsetCommand(redisClient *c) {$/;"	f
group	.\help.h	/^  int group;$/;"	m	struct:commandHelp
handleClientsBlockedOnLists	.\t_list.c	/^void handleClientsBlockedOnLists(void) {$/;"	f
hard_limit_bytes	.\redis.h	/^    unsigned long long hard_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
has_tail	.\config.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	struct:rewriteConfigState	file:
hashDictType	.\redis.c	/^dictType hashDictType = {$/;"	v
hashFunction	.\dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType
hashTypeConvert	.\t_hash.c	/^void hashTypeConvert(robj *o, int enc) {$/;"	f
hashTypeConvertZiplist	.\t_hash.c	/^void hashTypeConvertZiplist(robj *o, int enc) {$/;"	f
hashTypeCurrentFromHashTable	.\t_hash.c	/^void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst) {$/;"	f
hashTypeCurrentFromZiplist	.\t_hash.c	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	f
hashTypeCurrentObject	.\t_hash.c	/^robj *hashTypeCurrentObject(hashTypeIterator *hi, int what) {$/;"	f
hashTypeDelete	.\t_hash.c	/^int hashTypeDelete(robj *o, robj *field) {$/;"	f
hashTypeExists	.\t_hash.c	/^int hashTypeExists(robj *o, robj *field) {$/;"	f
hashTypeGetFromHashTable	.\t_hash.c	/^int hashTypeGetFromHashTable(robj *o, robj *field, robj **value) {$/;"	f
hashTypeGetFromZiplist	.\t_hash.c	/^int hashTypeGetFromZiplist(robj *o, robj *field,$/;"	f
hashTypeGetObject	.\t_hash.c	/^robj *hashTypeGetObject(robj *o, robj *field) {$/;"	f
hashTypeInitIterator	.\t_hash.c	/^hashTypeIterator *hashTypeInitIterator(robj *subject) {$/;"	f
hashTypeIterator	.\redis.h	/^} hashTypeIterator;$/;"	t	typeref:struct:__anon11
hashTypeLength	.\t_hash.c	/^unsigned long hashTypeLength(robj *o) {$/;"	f
hashTypeLookupWriteOrCreate	.\t_hash.c	/^robj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key) {$/;"	f
hashTypeNext	.\t_hash.c	/^int hashTypeNext(hashTypeIterator *hi) {$/;"	f
hashTypeReleaseIterator	.\t_hash.c	/^void hashTypeReleaseIterator(hashTypeIterator *hi) {$/;"	f
hashTypeSet	.\t_hash.c	/^int hashTypeSet(robj *o, robj *field, robj *value) {$/;"	f
hashTypeTryConversion	.\t_hash.c	/^void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {$/;"	f
hashTypeTryObjectEncoding	.\t_hash.c	/^void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {$/;"	f
hash_max_ziplist_entries	.\redis.h	/^    size_t hash_max_ziplist_entries;$/;"	m	struct:redisServer
hash_max_ziplist_value	.\redis.h	/^    size_t hash_max_ziplist_value;$/;"	m	struct:redisServer
hdelCommand	.\t_hash.c	/^void hdelCommand(redisClient *c) {$/;"	f
head	.\adlist.h	/^    listNode *head;$/;"	m	struct:list
header	.\redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode
headersize	.\ziplist.c	/^    unsigned int headersize;$/;"	m	struct:zlentry	file:
helpEntries	.\redis-cli.c	/^static helpEntry *helpEntries;$/;"	v	file:
helpEntriesLen	.\redis-cli.c	/^static int helpEntriesLen;$/;"	v	file:
helpEntry	.\redis-cli.c	/^} helpEntry;$/;"	t	typeref:struct:__anon6	file:
hex_digit_to_int	.\sds.c	/^int hex_digit_to_int(char c) {$/;"	f
hexistsCommand	.\t_hash.c	/^void hexistsCommand(redisClient *c) {$/;"	f
hgetCommand	.\t_hash.c	/^void hgetCommand(redisClient *c) {$/;"	f
hgetallCommand	.\t_hash.c	/^void hgetallCommand(redisClient *c) {$/;"	f
hincrbyCommand	.\t_hash.c	/^void hincrbyCommand(redisClient *c) {$/;"	f
hincrbyfloatCommand	.\t_hash.c	/^void hincrbyfloatCommand(redisClient *c) {$/;"	f
hkeysCommand	.\t_hash.c	/^void hkeysCommand(redisClient *c) {$/;"	f
hlenCommand	.\t_hash.c	/^void hlenCommand(redisClient *c) {$/;"	f
hmgetCommand	.\t_hash.c	/^void hmgetCommand(redisClient *c) {$/;"	f
hmsetCommand	.\t_hash.c	/^void hmsetCommand(redisClient *c) {$/;"	f
hostip	.\redis-benchmark.c	/^    const char *hostip;$/;"	m	struct:config	file:
hostip	.\redis-cli.c	/^    char *hostip;$/;"	m	struct:config	file:
hostport	.\redis-benchmark.c	/^    int hostport;$/;"	m	struct:config	file:
hostport	.\redis-cli.c	/^    int hostport;$/;"	m	struct:config	file:
hostsocket	.\redis-benchmark.c	/^    const char *hostsocket;$/;"	m	struct:config	file:
hostsocket	.\redis-cli.c	/^    char *hostsocket;$/;"	m	struct:config	file:
hscanCommand	.\t_hash.c	/^void hscanCommand(redisClient *c) {$/;"	f
hsetCommand	.\t_hash.c	/^void hsetCommand(redisClient *c) {$/;"	f
hsetnxCommand	.\t_hash.c	/^void hsetnxCommand(redisClient *c) {$/;"	f
ht	.\dict.h	/^    dictht ht[2];$/;"	m	struct:dict
ht	.\t_zset.c	/^            } ht;$/;"	m	union:__anon18::__anon19::_iterset	typeref:struct:__anon18::__anon19::_iterset::__anon21	file:
htNeedsResize	.\redis.c	/^int htNeedsResize(dict *dict) {$/;"	f
hvalsCommand	.\t_hash.c	/^void hvalsCommand(redisClient *c) {$/;"	f
hz	.\redis.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	struct:redisServer
id	.\ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
id	.\redis.h	/^    int id;$/;"	m	struct:redisDb
id	.\slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	struct:slowlogEntry
idlemode	.\redis-benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:
ii	.\redis.h	/^    int ii; \/* intset iterator *\/$/;"	m	struct:__anon10
ii	.\t_zset.c	/^                int ii;$/;"	m	struct:__anon18::__anon19::_iterset::__anon20	file:
incrCommand	.\t_string.c	/^void incrCommand(redisClient *c) {$/;"	f
incrDecrCommand	.\t_string.c	/^void incrDecrCommand(redisClient *c, long long incr) {$/;"	f
incrRefCount	.\object.c	/^void incrRefCount(robj *o) {$/;"	f
incrbyCommand	.\t_string.c	/^void incrbyCommand(redisClient *c) {$/;"	f
incrbyfloatCommand	.\t_string.c	/^void incrbyfloatCommand(redisClient *c) {$/;"	f
incrementallyRehash	.\redis.c	/^int incrementallyRehash(int dbid) {$/;"	f
index	.\dict.h	/^    int table, index, safe;$/;"	m	struct:dictIterator
infoCommand	.\redis.c	/^void infoCommand(redisClient *c) {$/;"	f
info_refresh	.\sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	struct:sentinelRedisInstance	file:
initClientMultiState	.\multi.c	/^void initClientMultiState(redisClient *c) {$/;"	f
initSentinel	.\sentinel.c	/^void initSentinel(void) {$/;"	f
initSentinelConfig	.\sentinel.c	/^void initSentinelConfig(void) {$/;"	f
initServer	.\redis.c	/^void initServer() {$/;"	f
initServerConfig	.\redis.c	/^void initServerConfig() {$/;"	f
initStaticStringObject	.\redis.h	392;"	d
inline	.\lzf_c.c	80;"	d	file:
inline	.\lzf_c.c	83;"	d	file:
instancesDictType	.\sentinel.c	/^dictType instancesDictType = {$/;"	v
integers	.\redis.h	/^    *integers[REDIS_SHARED_INTEGERS],$/;"	m	struct:sharedObjectsStruct
interactive	.\redis-cli.c	/^    int interactive;$/;"	m	struct:config	file:
interval	.\redis-cli.c	/^    long interval;$/;"	m	struct:config	file:
intrev16	.\endianconv.c	/^uint16_t intrev16(uint16_t v) {$/;"	f
intrev16ifbe	.\endianconv.h	52;"	d
intrev16ifbe	.\endianconv.h	59;"	d
intrev32	.\endianconv.c	/^uint32_t intrev32(uint32_t v) {$/;"	f
intrev32ifbe	.\endianconv.h	53;"	d
intrev32ifbe	.\endianconv.h	60;"	d
intrev64	.\endianconv.c	/^uint64_t intrev64(uint64_t v) {$/;"	f
intrev64ifbe	.\endianconv.h	54;"	d
intrev64ifbe	.\endianconv.h	61;"	d
intset	.\intset.h	/^typedef struct intset {$/;"	s
intset	.\intset.h	/^} intset;$/;"	t	typeref:struct:intset
intsetAdd	.\intset.c	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {$/;"	f
intsetBlobLen	.\intset.c	/^size_t intsetBlobLen(intset *is) {$/;"	f
intsetFind	.\intset.c	/^uint8_t intsetFind(intset *is, int64_t value) {$/;"	f
intsetGet	.\intset.c	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {$/;"	f
intsetLen	.\intset.c	/^uint32_t intsetLen(intset *is) {$/;"	f
intsetMoveTail	.\intset.c	/^static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {$/;"	f	file:
intsetNew	.\intset.c	/^intset *intsetNew(void) {$/;"	f
intsetRandom	.\intset.c	/^int64_t intsetRandom(intset *is) {$/;"	f
intsetRemove	.\intset.c	/^intset *intsetRemove(intset *is, int64_t value, int *success) {$/;"	f
intsetRepr	.\intset.c	/^void intsetRepr(intset *is) {$/;"	f
intsetResize	.\intset.c	/^static intset *intsetResize(intset *is, uint32_t len) {$/;"	f	file:
intsetSearch	.\intset.c	/^static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {$/;"	f	file:
intsetUpgradeAndAdd	.\intset.c	/^static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {$/;"	f	file:
io	.\rio.h	/^    } io;$/;"	m	struct:_rio	typeref:union:_rio::__anon13
ip	.\sentinel.c	/^    char *ip;$/;"	m	struct:sentinelAddr	file:
ipfd	.\redis.h	/^    int ipfd[REDIS_BINDADDR_MAX]; \/* TCP socket file descriptors *\/$/;"	m	struct:redisServer
ipfd_count	.\redis.h	/^    int ipfd_count;             \/* Used slots in ipfd[] *\/$/;"	m	struct:redisServer
is	.\t_zset.c	/^                intset *is;$/;"	m	struct:__anon18::__anon19::_iterset::__anon20	file:
is	.\t_zset.c	/^            } is;$/;"	m	union:__anon18::__anon19::_iterset	typeref:struct:__anon18::__anon19::_iterset::__anon20	file:
isObjectRepresentableAsLongLong	.\object.c	/^int isObjectRepresentableAsLongLong(robj *o, long long *llval) {$/;"	f
is_hex_digit	.\sds.c	/^int is_hex_digit(char c) {$/;"	f
isfinite	.\solarisfixes.h	38;"	d
isfinite	.\solarisfixes.h	39;"	d
isinf	.\solarisfixes.h	43;"	d
isinf	.\solarisfixes.h	44;"	d
isnan	.\solarisfixes.h	33;"	d
isnan	.\solarisfixes.h	34;"	d
iter	.\t_zset.c	/^    } iter;$/;"	m	struct:__anon18	typeref:union:__anon18::__anon19	file:
iterators	.\dict.h	/^    int iterators; \/* number of iterators currently running *\/$/;"	m	struct:dict
iterset	.\t_zset.c	/^typedef union _iterset iterset;$/;"	t	typeref:union:_iterset	file:
iterzset	.\t_zset.c	/^typedef union _iterzset iterzset;$/;"	t	typeref:union:_iterzset	file:
keepalive	.\redis-benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:
key	.\dict.h	/^    void *key;$/;"	m	struct:dictEntry
key	.\multi.c	/^    robj *key;$/;"	m	struct:watchedKey	file:
key	.\redis-check-dump.c	/^    char* key;$/;"	m	struct:__anon5	file:
key	.\redis.h	/^    robj *key;$/;"	m	struct:readyList
keyCompare	.\dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType
keyDestructor	.\dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType
keyDup	.\dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType
keylistDictType	.\redis.c	/^dictType keylistDictType = {$/;"	v
keyptrDictType	.\redis.c	/^dictType keyptrDictType = {$/;"	v
keys	.\redis.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	struct:blockingState
keysCommand	.\db.c	/^void keysCommand(redisClient *c) {$/;"	f
keysize	.\redis-benchmark.c	/^    int keysize;$/;"	m	struct:config	file:
keyspaceEventsFlagsToString	.\notify.c	/^sds keyspaceEventsFlagsToString(int flags) {$/;"	f
keyspaceEventsStringToFlags	.\notify.c	/^int keyspaceEventsStringToFlags(char *classes) {$/;"	f
keystep	.\redis.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand
kqfd	.\ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
lastTime	.\ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	struct:aeEventLoop
last_avail_time	.\sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	struct:sentinelRedisInstance	file:
last_hello_time	.\sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	struct:sentinelRedisInstance	file:
last_master_down_reply_time	.\sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	struct:sentinelRedisInstance	file:
last_pong_time	.\sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	struct:sentinelRedisInstance	file:
last_pub_time	.\sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:
lastbgsave_status	.\redis.h	/^    int lastbgsave_status;          \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer
lastbgsave_try	.\redis.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	struct:redisServer
lastcmd	.\redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::
lastinteraction	.\redis.h	/^    time_t lastinteraction; \/* time of the last interaction, used for timeout *\/$/;"	m	struct:redisClient
lastkey	.\redis.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:redisCommand
lastsave	.\redis.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	struct:redisServer
lastsaveCommand	.\db.c	/^void lastsaveCommand(redisClient *c) {$/;"	f
latency	.\redis-benchmark.c	/^    long long *latency;$/;"	m	struct:config	file:
latency	.\redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	struct:_client	file:
latencyMode	.\redis-cli.c	/^static void latencyMode(void) {$/;"	f	file:
latency_history	.\redis-cli.c	/^    int latency_history;$/;"	m	struct:config	file:
latency_mode	.\redis-cli.c	/^    int latency_mode;$/;"	m	struct:config	file:
leader	.\sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	struct:sentinelRedisInstance	file:
leaderVotesDictType	.\sentinel.c	/^dictType leaderVotesDictType = {$/;"	v
leader_epoch	.\sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	struct:sentinelRedisInstance	file:
len	.\adlist.h	/^    unsigned long len;$/;"	m	struct:list
len	.\sds.h	/^    int len;$/;"	m	struct:sdshdr
len	.\ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:
length	.\intset.h	/^    uint32_t length;$/;"	m	struct:intset
length	.\redis.h	/^    unsigned long length;$/;"	m	struct:zskiplist
lensize	.\ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:
level	.\redis-check-dump.c	/^    size_t level;$/;"	m	struct:__anon4	file:
level	.\redis-check-dump.c	/^static unsigned char level = 0;$/;"	v	file:
level	.\redis.h	/^    int level;$/;"	m	struct:zskiplist
level	.\redis.h	/^    } level[];$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel
li	.\redis.h	/^    listTypeIterator *li;$/;"	m	struct:__anon9
lindexCommand	.\t_list.c	/^void lindexCommand(redisClient *c) {$/;"	f
lines	.\config.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	struct:rewriteConfigState	file:
linsertCommand	.\t_list.c	/^void linsertCommand(redisClient *c) {$/;"	f
linuxOvercommitMemoryValue	.\redis.c	/^int linuxOvercommitMemoryValue(void) {$/;"	f
linuxOvercommitMemoryWarning	.\redis.c	/^void linuxOvercommitMemoryWarning(void) {$/;"	f
list	.\adlist.h	/^typedef struct list {$/;"	s
list	.\adlist.h	/^} list;$/;"	t	typeref:struct:list
listAddNodeHead	.\adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f
listAddNodeTail	.\adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f
listCreate	.\adlist.c	/^list *listCreate(void)$/;"	f
listDelNode	.\adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f
listDup	.\adlist.c	/^list *listDup(list *orig)$/;"	f
listGetDupMethod	.\adlist.h	70;"	d
listGetFree	.\adlist.h	71;"	d
listGetIterator	.\adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f
listGetMatchMethod	.\adlist.h	72;"	d
listIndex	.\adlist.c	/^listNode *listIndex(list *list, long index) {$/;"	f
listInsertNode	.\adlist.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f
listIter	.\adlist.h	/^typedef struct listIter {$/;"	s
listIter	.\adlist.h	/^} listIter;$/;"	t	typeref:struct:listIter
listLast	.\adlist.h	61;"	d
listLength	.\adlist.h	59;"	d
listMatchObjects	.\networking.c	/^int listMatchObjects(void *a, void *b) {$/;"	f
listMatchPubsubPattern	.\pubsub.c	/^int listMatchPubsubPattern(void *a, void *b) {$/;"	f
listNext	.\adlist.c	/^listNode *listNext(listIter *iter)$/;"	f
listNextNode	.\adlist.h	63;"	d
listNode	.\adlist.h	/^typedef struct listNode {$/;"	s
listNode	.\adlist.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNodeValue	.\adlist.h	64;"	d
listPrevNode	.\adlist.h	62;"	d
listRelease	.\adlist.c	/^void listRelease(list *list)$/;"	f
listReleaseIterator	.\adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f
listRewind	.\adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f
listRewindTail	.\adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f
listRotate	.\adlist.c	/^void listRotate(list *list) {$/;"	f
listSearchKey	.\adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f
listSetDupMethod	.\adlist.h	66;"	d
listSetFreeMethod	.\adlist.h	67;"	d
listSetMatchMethod	.\adlist.h	68;"	d
listTypeConvert	.\t_list.c	/^void listTypeConvert(robj *subject, int enc) {$/;"	f
listTypeDelete	.\t_list.c	/^void listTypeDelete(listTypeEntry *entry) {$/;"	f
listTypeEntry	.\redis.h	/^} listTypeEntry;$/;"	t	typeref:struct:__anon9
listTypeEqual	.\t_list.c	/^int listTypeEqual(listTypeEntry *entry, robj *o) {$/;"	f
listTypeGet	.\t_list.c	/^robj *listTypeGet(listTypeEntry *entry) {$/;"	f
listTypeInitIterator	.\t_list.c	/^listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction) {$/;"	f
listTypeInsert	.\t_list.c	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where) {$/;"	f
listTypeIterator	.\redis.h	/^} listTypeIterator;$/;"	t	typeref:struct:__anon8
listTypeLength	.\t_list.c	/^unsigned long listTypeLength(robj *subject) {$/;"	f
listTypeNext	.\t_list.c	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {$/;"	f
listTypePop	.\t_list.c	/^robj *listTypePop(robj *subject, int where) {$/;"	f
listTypePush	.\t_list.c	/^void listTypePush(robj *subject, robj *value, int where) {$/;"	f
listTypeReleaseIterator	.\t_list.c	/^void listTypeReleaseIterator(listTypeIterator *li) {$/;"	f
listTypeTryConversion	.\t_list.c	/^void listTypeTryConversion(robj *subject, robj *value) {$/;"	f
list_max_ziplist_entries	.\redis.h	/^    size_t list_max_ziplist_entries;$/;"	m	struct:redisServer
list_max_ziplist_value	.\redis.h	/^    size_t list_max_ziplist_value;$/;"	m	struct:redisServer
listenToPort	.\redis.c	/^int listenToPort(int port, int *fds, int *count) {$/;"	f
liveclients	.\redis-benchmark.c	/^    int liveclients;$/;"	m	struct:config	file:
ll2string	.\util.c	/^int ll2string(char *s, size_t len, long long value) {$/;"	f
llenCommand	.\t_list.c	/^void llenCommand(redisClient *c) {$/;"	f
ln	.\redis.h	/^    listNode *ln;       \/* Entry in linked list *\/$/;"	m	struct:__anon9
ln	.\redis.h	/^    listNode *ln;$/;"	m	struct:__anon8
loadAppendOnlyFile	.\aof.c	/^int loadAppendOnlyFile(char *filename) {$/;"	f
loadDataFromDisk	.\redis.c	/^void loadDataFromDisk(void) {$/;"	f
loadDoubleValue	.\redis-check-dump.c	/^double* loadDoubleValue() {$/;"	f
loadEntry	.\redis-check-dump.c	/^entry loadEntry() {$/;"	f
loadIntegerObject	.\redis-check-dump.c	/^char *loadIntegerObject(int enctype) {$/;"	f
loadLength	.\redis-check-dump.c	/^uint32_t loadLength(int *isencoded) {$/;"	f
loadLzfStringObject	.\redis-check-dump.c	/^char* loadLzfStringObject() {$/;"	f
loadPair	.\redis-check-dump.c	/^int loadPair(entry *e) {$/;"	f
loadServerConfig	.\config.c	/^void loadServerConfig(char *filename, char *options) {$/;"	f
loadServerConfigFromString	.\config.c	/^void loadServerConfigFromString(char *config) {$/;"	f
loadStringObject	.\redis-check-dump.c	/^char* loadStringObject() {$/;"	f
loadType	.\redis-check-dump.c	/^int loadType(entry *e) {$/;"	f
loading	.\redis.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	struct:redisServer
loadingProgress	.\rdb.c	/^void loadingProgress(off_t pos) {$/;"	f
loading_loaded_bytes	.\redis.h	/^    off_t loading_loaded_bytes;$/;"	m	struct:redisServer
loading_process_events_interval_bytes	.\redis.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	struct:redisServer
loading_start_time	.\redis.h	/^    time_t loading_start_time;$/;"	m	struct:redisServer
loading_total_bytes	.\redis.h	/^    off_t loading_total_bytes;$/;"	m	struct:redisServer
loadingerr	.\redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
logCurrentClient	.\debug.c	/^void logCurrentClient(void) {$/;"	f
logRegisters	.\debug.c	/^void logRegisters(ucontext_t *uc) {$/;"	f
logStackContent	.\debug.c	/^void logStackContent(void **sp) {$/;"	f
logStackTrace	.\debug.c	/^void logStackTrace(ucontext_t *uc) {$/;"	f
logfile	.\redis.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	struct:redisServer
lookupCommand	.\redis.c	/^struct redisCommand *lookupCommand(sds name) {$/;"	f
lookupCommandByCString	.\redis.c	/^struct redisCommand *lookupCommandByCString(char *s) {$/;"	f
lookupCommandOrOriginal	.\redis.c	/^struct redisCommand *lookupCommandOrOriginal(sds name) {$/;"	f
lookupKey	.\db.c	/^robj *lookupKey(redisDb *db, robj *key) {$/;"	f
lookupKeyByPattern	.\sort.c	/^robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {$/;"	f
lookupKeyRead	.\db.c	/^robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f
lookupKeyReadOrReply	.\db.c	/^robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f
lookupKeyWrite	.\db.c	/^robj *lookupKeyWrite(redisDb *db, robj *key) {$/;"	f
lookupKeyWriteOrReply	.\db.c	/^robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f
loop	.\redis-benchmark.c	/^    int loop;$/;"	m	struct:config	file:
loop	.\sentinel.c	/^    aeEventLoop *loop;$/;"	m	struct:redisAeEvents	file:
lpop	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
lpopCommand	.\redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,*rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
lpopCommand	.\t_list.c	/^void lpopCommand(redisClient *c) {$/;"	f
lpush	.\redis.h	/^    *lpush, *emptyscan,$/;"	m	struct:sharedObjectsStruct
lpushCommand	.\redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,*rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
lpushCommand	.\t_list.c	/^void lpushCommand(redisClient *c) {$/;"	f
lpushxCommand	.\t_list.c	/^void lpushxCommand(redisClient *c) {$/;"	f
lrangeCommand	.\t_list.c	/^void lrangeCommand(redisClient *c) {$/;"	f
lremCommand	.\t_list.c	/^void lremCommand(redisClient *c) {$/;"	f
lru	.\redis.h	/^    unsigned lru:22;        \/* lru time (relative to server.lruclock) *\/$/;"	m	struct:redisObject
lruclock	.\redis.h	/^    unsigned lruclock:22;       \/* Clock incrementing every minute, for LRU *\/$/;"	m	struct:redisServer
lruclock_padding	.\redis.h	/^    unsigned lruclock_padding:10;$/;"	m	struct:redisServer
lsetCommand	.\t_list.c	/^void lsetCommand(redisClient *c) {$/;"	f
ltrimCommand	.\t_list.c	/^void ltrimCommand(redisClient *c) {$/;"	f
lua	.\redis.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	struct:redisServer
luaCreateFunction	.\scripting.c	/^int luaCreateFunction(redisClient *c, lua_State *lua, char *funcname, robj *body) {$/;"	f
luaLoadLib	.\scripting.c	/^void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {$/;"	f
luaLoadLibraries	.\scripting.c	/^void luaLoadLibraries(lua_State *lua) {$/;"	f
luaLogCommand	.\scripting.c	/^int luaLogCommand(lua_State *lua) {$/;"	f
luaMaskCountHook	.\scripting.c	/^void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {$/;"	f
luaPushError	.\scripting.c	/^void luaPushError(lua_State *lua, char *error) {$/;"	f
luaRedisCallCommand	.\scripting.c	/^int luaRedisCallCommand(lua_State *lua) {$/;"	f
luaRedisErrorReplyCommand	.\scripting.c	/^int luaRedisErrorReplyCommand(lua_State *lua) {$/;"	f
luaRedisGenericCommand	.\scripting.c	/^int luaRedisGenericCommand(lua_State *lua, int raise_error) {$/;"	f
luaRedisPCallCommand	.\scripting.c	/^int luaRedisPCallCommand(lua_State *lua) {$/;"	f
luaRedisReturnSingleFieldTable	.\scripting.c	/^int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {$/;"	f
luaRedisSha1hexCommand	.\scripting.c	/^int luaRedisSha1hexCommand(lua_State *lua) {$/;"	f
luaRedisStatusReplyCommand	.\scripting.c	/^int luaRedisStatusReplyCommand(lua_State *lua) {$/;"	f
luaRemoveUnsupportedFunctions	.\scripting.c	/^void luaRemoveUnsupportedFunctions(lua_State *lua) {$/;"	f
luaReplyToRedisReply	.\scripting.c	/^void luaReplyToRedisReply(redisClient *c, lua_State *lua) {$/;"	f
luaSetGlobalArray	.\scripting.c	/^void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {$/;"	f
luaSortArray	.\scripting.c	/^void luaSortArray(lua_State *lua) {$/;"	f
lua_caller	.\redis.h	/^    redisClient *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	struct:redisServer
lua_client	.\redis.h	/^    redisClient *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	struct:redisServer
lua_kill	.\redis.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	struct:redisServer
lua_random_dirty	.\redis.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	struct:redisServer
lua_scripts	.\redis.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	struct:redisServer
lua_time_limit	.\redis.h	/^    long long lua_time_limit;  \/* Script timeout in seconds *\/$/;"	m	struct:redisServer
lua_time_start	.\redis.h	/^    long long lua_time_start;  \/* Start time of script *\/$/;"	m	struct:redisServer
lua_timedout	.\redis.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	struct:redisServer
lua_write_dirty	.\redis.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	struct:redisServer
lzf_compress	.\lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f
lzf_decompress	.\lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f
main	.\crc64.c	/^int main(void) {$/;"	f
main	.\endianconv.c	/^int main(void) {$/;"	f
main	.\intset.c	/^int main(int argc, char **argv) {$/;"	f
main	.\redis-benchmark.c	/^int main(int argc, const char **argv) {$/;"	f
main	.\redis-check-aof.c	/^int main(int argc, char **argv) {$/;"	f
main	.\redis-check-dump.c	/^int main(int argc, char **argv) {$/;"	f
main	.\redis-cli.c	/^int main(int argc, char **argv) {$/;"	f
main	.\redis.c	/^int main(int argc, char **argv) {$/;"	f
main	.\sds.c	/^int main(void) {$/;"	f
main	.\util.c	/^int main(int argc, char **argv) {$/;"	f
main	.\ziplist.c	/^int main(int argc, char **argv) {$/;"	f
main	.\zipmap.c	/^int main(void) {$/;"	f
malloc	.\zmalloc.c	59;"	d	file:
malloc	.\zmalloc.c	64;"	d	file:
mask	.\ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	.\ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
master	.\redis.h	/^    redisClient *master;     \/* Client that is master for this slave *\/$/;"	m	struct:redisServer
master	.\sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:
masterTryPartialResynchronization	.\replication.c	/^int masterTryPartialResynchronization(redisClient *c) {$/;"	f
master_link_down_time	.\sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	struct:sentinelRedisInstance	file:
master_repl_offset	.\redis.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	struct:redisServer
masterauth	.\redis.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	struct:redisServer
masterdownerr	.\redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
masterhost	.\redis.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	struct:redisServer
masterport	.\redis.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	struct:redisServer
masters	.\sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	struct:sentinelState	file:
match	.\adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list
max	.\redis.h	/^    double min, max;$/;"	m	struct:__anon12
max_processing_chunk	.\rio.h	/^    size_t max_processing_chunk;$/;"	m	struct:_rio
maxclients	.\redis.h	/^    unsigned int maxclients;        \/* Max number of simultaneous clients *\/$/;"	m	struct:redisServer
maxex	.\redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon12
maxfd	.\ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop
maxidletime	.\redis.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	struct:redisServer
maxmemory	.\redis.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	struct:redisServer
maxmemory_policy	.\redis.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	struct:redisServer
maxmemory_samples	.\redis.h	/^    int maxmemory_samples;          \/* Pricision of random sampling *\/$/;"	m	struct:redisServer
mb_delim	.\redis-cli.c	/^    sds mb_delim;$/;"	m	struct:config	file:
mbulkhdr	.\redis.h	/^    *mbulkhdr[REDIS_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
med3	.\pqsort.c	/^med3(char *a, char *b, char *c,$/;"	f	file:
memrev16	.\endianconv.c	/^void memrev16(void *p) {$/;"	f
memrev16ifbe	.\endianconv.h	49;"	d
memrev16ifbe	.\endianconv.h	56;"	d
memrev32	.\endianconv.c	/^void memrev32(void *p) {$/;"	f
memrev32ifbe	.\endianconv.h	50;"	d
memrev32ifbe	.\endianconv.h	57;"	d
memrev64	.\endianconv.c	/^void memrev64(void *p) {$/;"	f
memrev64ifbe	.\endianconv.h	51;"	d
memrev64ifbe	.\endianconv.h	58;"	d
memtest	.\memtest.c	/^void memtest(size_t megabytes, int passes) {$/;"	f
memtest_addressing	.\memtest.c	/^void memtest_addressing(unsigned long *l, size_t bytes) {$/;"	f
memtest_compare	.\memtest.c	/^void memtest_compare(unsigned long *l, size_t bytes) {$/;"	f
memtest_compare_times	.\memtest.c	/^void memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times) {$/;"	f
memtest_fill_random	.\memtest.c	/^void memtest_fill_random(unsigned long *l, size_t bytes) {$/;"	f
memtest_fill_value	.\memtest.c	/^void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,$/;"	f
memtest_non_destructive_invert	.\memtest.c	/^void memtest_non_destructive_invert(void *addr, size_t size) {$/;"	f
memtest_non_destructive_swap	.\memtest.c	/^void memtest_non_destructive_swap(void *addr, size_t size) {$/;"	f
memtest_progress_end	.\memtest.c	/^void memtest_progress_end(void) {$/;"	f
memtest_progress_start	.\memtest.c	/^void memtest_progress_start(char *title, int pass) {$/;"	f
memtest_progress_step	.\memtest.c	/^void memtest_progress_step(size_t curr, size_t size, char c) {$/;"	f
memtest_test	.\memtest.c	/^void memtest_test(size_t megabytes, int passes) {$/;"	f
memtest_test_linux_anonymous_maps	.\debug.c	/^int memtest_test_linux_anonymous_maps(void) {$/;"	f
memtoll	.\util.c	/^long long memtoll(const char *p, int *err) {$/;"	f
messagebulk	.\redis.h	/^    *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
mgetCommand	.\t_string.c	/^void mgetCommand(redisClient *c) {$/;"	f
microseconds	.\redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand
migrateCommand	.\migrate.c	/^void migrateCommand(redisClient *c) {$/;"	f
min	.\pqsort.c	49;"	d	file:
min	.\redis.h	/^    double min, max;$/;"	m	struct:__anon12
minex	.\redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon12
minreplicas	.\redis.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	struct:multiState
minreplicas_timeout	.\redis.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	struct:multiState
mixDigest	.\debug.c	/^void mixDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f
mixObjectDigest	.\debug.c	/^void mixObjectDigest(unsigned char *digest, robj *o) {$/;"	f
monitorCommand	.\redis.c	/^void monitorCommand(redisClient *c) {$/;"	f
monitor_mode	.\redis-cli.c	/^    int monitor_mode;$/;"	m	struct:config	file:
monitors	.\redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer
moveCommand	.\db.c	/^void moveCommand(redisClient *c) {$/;"	f
msetCommand	.\t_string.c	/^void msetCommand(redisClient *c) {$/;"	f
msetGenericCommand	.\t_string.c	/^void msetGenericCommand(redisClient *c, int nx) {$/;"	f
msetnxCommand	.\t_string.c	/^void msetnxCommand(redisClient *c) {$/;"	f
mstate	.\redis.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:redisClient
mstime	.\redis-benchmark.c	/^static long long mstime(void) {$/;"	f	file:
mstime	.\redis-cli.c	/^static long long mstime(void) {$/;"	f	file:
mstime	.\redis.c	/^long long mstime(void) {$/;"	f
mstime	.\redis.h	/^    long long mstime;       \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	struct:redisServer
mstime_t	.\sentinel.c	/^typedef long long mstime_t; \/* millisecond time type. *\/$/;"	t	file:
multiCmd	.\redis.h	/^typedef struct multiCmd {$/;"	s
multiCmd	.\redis.h	/^} multiCmd;$/;"	t	typeref:struct:multiCmd
multiCommand	.\multi.c	/^void multiCommand(redisClient *c) {$/;"	f
multiCommand	.\redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,*rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
multiState	.\redis.h	/^typedef struct multiState {$/;"	s
multiState	.\redis.h	/^} multiState;$/;"	t	typeref:struct:multiState
multibulklen	.\redis.h	/^    int multibulklen;       \/* number of multi bulk arguments left to read *\/$/;"	m	struct:redisClient
name	.\config.c	/^    const char     *name;$/;"	m	struct:__anon1	file:
name	.\help.h	/^  char *name;$/;"	m	struct:commandHelp
name	.\redis.h	/^    char *name;$/;"	m	struct:redisCommand
name	.\redis.h	/^    char *name;$/;"	m	struct:redisFunctionSym
name	.\redis.h	/^    robj *name;             \/* As set by CLIENT SETNAME *\/$/;"	m	struct:redisClient
name	.\sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	struct:sentinelRedisInstance	file:
neterr	.\redis.h	/^    char neterr[ANET_ERR_LEN];  \/* Error buffer for anet.c *\/$/;"	m	struct:redisServer
next	.\adlist.h	/^    listNode *next;$/;"	m	struct:listIter
next	.\adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
next	.\ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	.\dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry
next	.\rand.c	/^static void next() {$/;"	f	file:
nextEntry	.\dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
noPreloadGetKeys	.\db.c	/^int *noPreloadGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys, int flags) {$/;"	f
noautherr	.\redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
node	.\t_zset.c	/^                zskiplistNode *node;$/;"	m	struct:__anon18::__anon19::_iterzset::__anon23	file:
nokeyerr	.\redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
noninteractive	.\redis-cli.c	/^static int noninteractive(int argc, char **argv) {$/;"	f	file:
noreplicaserr	.\redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
noscripterr	.\redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
notification_script	.\sentinel.c	/^    char *notification_script;$/;"	m	struct:sentinelRedisInstance	file:
notifyKeyspaceEvent	.\notify.c	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {$/;"	f
notify_keyspace_events	.\redis.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:redisServer
notused	.\redis.h	/^    unsigned notused:2;     \/* Not used *\/$/;"	m	struct:redisObject
npending	.\ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:
nul	.\setproctitle.c	/^	char *nul;$/;"	m	struct:__anon16	file:
nullbulk	.\redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
nullmultibulk	.\redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
numclients	.\redis-benchmark.c	/^    int numclients;$/;"	m	struct:config	file:
numlines	.\config.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	struct:rewriteConfigState	file:
numops	.\redis.h	/^    int numops;$/;"	m	struct:redisOpArray
o_down_since_time	.\sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:
obj	.\redis.h	/^    robj *obj;$/;"	m	struct:_redisSortObject
obj	.\redis.h	/^    robj *obj;$/;"	m	struct:zskiplistNode
objectCommand	.\object.c	/^void objectCommand(redisClient *c) {$/;"	f
objectCommandLookup	.\object.c	/^robj *objectCommandLookup(redisClient *c, robj *key) {$/;"	f
objectCommandLookupOrReply	.\object.c	/^robj *objectCommandLookupOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f
obuf	.\redis-benchmark.c	/^    sds obuf;$/;"	m	struct:_client	file:
obuf_soft_limit_reached_time	.\redis.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	struct:redisClient
offset	.\redis-check-dump.c	/^    size_t offset;$/;"	m	struct:__anon3	file:
offset	.\redis-check-dump.c	/^    size_t offset[16];$/;"	m	struct:__anon4	file:
ok	.\intset.c	/^void ok(void) {$/;"	f
ok	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
oomerr	.\redis.h	/^    *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
ops	.\redis.h	/^    redisOp *ops;$/;"	m	struct:redisOpArray
ops_sec_idx	.\redis.h	/^    int ops_sec_idx;$/;"	m	struct:redisServer
ops_sec_last_sample_ops	.\redis.h	/^    long long ops_sec_last_sample_ops;  \/* numcommands in last sample *\/$/;"	m	struct:redisServer
ops_sec_last_sample_time	.\redis.h	/^    long long ops_sec_last_sample_time; \/* Timestamp of last sample (in ms) *\/$/;"	m	struct:redisServer
ops_sec_samples	.\redis.h	/^    long long ops_sec_samples[REDIS_OPS_SEC_SAMPLES];$/;"	m	struct:redisServer
optionSetDictType	.\config.c	/^dictType optionSetDictType = {$/;"	v
optionToLineDictType	.\config.c	/^dictType optionToLineDictType = {$/;"	v
option_to_line	.\config.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	struct:rewriteConfigState	file:
org	.\redis-cli.c	/^    struct commandHelp *org;$/;"	m	struct:__anon6	typeref:struct:__anon6::commandHelp	file:
orig_commands	.\redis.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	struct:redisServer
outofrangeerr	.\redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
output	.\redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	struct:config	file:
p	.\ziplist.c	/^    unsigned char *p;$/;"	m	struct:zlentry	file:
parallel_syncs	.\sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	struct:sentinelRedisInstance	file:
params	.\help.h	/^  char *params;$/;"	m	struct:commandHelp
parseOptions	.\redis-benchmark.c	/^int parseOptions(int argc, const char **argv) {$/;"	f
parseOptions	.\redis-cli.c	/^static int parseOptions(int argc, char **argv) {$/;"	f	file:
parseScanCursorOrReply	.\db.c	/^int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor) {$/;"	f
pathIsBaseName	.\util.c	/^int pathIsBaseName(char *path) {$/;"	f
pattern	.\redis.h	/^    robj *pattern;$/;"	m	struct:_redisSortOperation
pattern	.\redis.h	/^    robj *pattern;$/;"	m	struct:pubsubPattern
pc	.\sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:
pc_conn_time	.\sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:
pc_last_activity	.\sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	struct:sentinelRedisInstance	file:
peekType	.\redis-check-dump.c	/^int peekType() {$/;"	f
pending	.\redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	struct:_client	file:
pending_commands	.\sentinel.c	/^    int pending_commands;   \/* Number of commands sent waiting for a reply. *\/$/;"	m	struct:sentinelRedisInstance	file:
pending_fds	.\ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:
pending_masks	.\ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:
persistCommand	.\db.c	/^void persistCommand(redisClient *c) {$/;"	f
pexpireCommand	.\db.c	/^void pexpireCommand(redisClient *c) {$/;"	f
pexpireatCommand	.\db.c	/^void pexpireatCommand(redisClient *c) {$/;"	f
pid	.\sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	struct:sentinelScriptJob	file:
pidfile	.\redis.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	struct:redisServer
pingCommand	.\redis.c	/^void pingCommand(redisClient *c) {$/;"	f
pipeMode	.\redis-cli.c	/^static void pipeMode(void) {$/;"	f	file:
pipe_mode	.\redis-cli.c	/^    int pipe_mode;$/;"	m	struct:config	file:
pipe_timeout	.\redis-cli.c	/^    int pipe_timeout;$/;"	m	struct:config	file:
pipeline	.\redis-benchmark.c	/^    int pipeline;$/;"	m	struct:config	file:
plus	.\redis.h	/^    *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pmessagebulk	.\redis.h	/^    *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pointer	.\redis.h	/^    unsigned long pointer;$/;"	m	struct:redisFunctionSym
pong	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
pop	.\ziplist.c	/^void pop(unsigned char *zl, int where) {$/;"	f
popGenericCommand	.\t_list.c	/^void popGenericCommand(redisClient *c, int where) {$/;"	f
populateCommandTable	.\redis.c	/^void populateCommandTable(void) {$/;"	f
port	.\redis.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	struct:redisServer
port	.\sentinel.c	/^    int port;$/;"	m	struct:sentinelAddr	file:
portfd	.\ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:
pos	.\redis-check-dump.c	/^} pos;$/;"	t	typeref:struct:__anon3	file:
pos	.\rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon13::__anon14
positions	.\redis-check-dump.c	/^static pos positions[16];$/;"	v	file:
pqsort	.\pqsort.c	/^pqsort(void *a, size_t n, size_t es,$/;"	f
prepareClientToWrite	.\networking.c	/^int prepareClientToWrite(redisClient *c) {$/;"	f
prepareForShutdown	.\redis.c	/^int prepareForShutdown(int flags) {$/;"	f
prev	.\adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
previous_time	.\sentinel.c	/^    mstime_t previous_time;     \/* Last time we ran the time handler. *\/$/;"	m	struct:sentinelState	file:
prevrawlen	.\ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:
prevrawlensize	.\ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:
printCentered	.\redis-check-dump.c	/^void printCentered(int indent, int width, char* body) {$/;"	f
printErrorStack	.\redis-check-dump.c	/^void printErrorStack(entry *e) {$/;"	f
printSkipped	.\redis-check-dump.c	/^void printSkipped(uint64_t bytes, uint64_t offset) {$/;"	f
printValid	.\redis-check-dump.c	/^void printValid(uint64_t ops, uint64_t bytes) {$/;"	f
privdata	.\dict.h	/^    void *privdata;$/;"	m	struct:dict
proc	.\redis.h	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand
process	.\redis-check-aof.c	/^off_t process(FILE *fp) {$/;"	f
process	.\redis-check-dump.c	/^void process() {$/;"	f
processCommand	.\redis.c	/^int processCommand(redisClient *c) {$/;"	f
processDoubleValue	.\redis-check-dump.c	/^int processDoubleValue(double** store) {$/;"	f
processHeader	.\redis-check-dump.c	/^int processHeader() {$/;"	f
processInlineBuffer	.\networking.c	/^int processInlineBuffer(redisClient *c) {$/;"	f
processInputBuffer	.\networking.c	/^void processInputBuffer(redisClient *c) {$/;"	f
processMultibulkBuffer	.\networking.c	/^int processMultibulkBuffer(redisClient *c) {$/;"	f
processStringObject	.\redis-check-dump.c	/^int processStringObject(char** store) {$/;"	f
processTime	.\redis-check-dump.c	/^int processTime(int type) {$/;"	f
processTimeEvents	.\ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
processed_bytes	.\rio.h	/^    size_t processed_bytes;$/;"	m	struct:_rio
progress_full	.\memtest.c	/^size_t progress_full; \/* How many chars to write to fill the progress bar. *\/$/;"	v
progress_printed	.\memtest.c	/^size_t progress_printed; \/* Printed chars in screen-wide progress bar. *\/$/;"	v
promoted_slave	.\sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:
prompt	.\redis-cli.c	/^    char prompt[128];$/;"	m	struct:config	file:
propagate	.\redis.c	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
propagateExpire	.\db.c	/^void propagateExpire(redisDb *db, robj *key) {$/;"	f
psetexCommand	.\t_string.c	/^void psetexCommand(redisClient *c) {$/;"	f
psubscribeCommand	.\pubsub.c	/^void psubscribeCommand(redisClient *c) {$/;"	f
psubscribebulk	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
ptr	.\redis.h	/^    void *ptr;$/;"	m	struct:redisObject
ptr	.\rio.h	/^            sds ptr;$/;"	m	struct:_rio::__anon13::__anon14
pttlCommand	.\db.c	/^void pttlCommand(redisClient *c) {$/;"	f
publishCommand	.\pubsub.c	/^void publishCommand(redisClient *c) {$/;"	f
pubsubCommand	.\pubsub.c	/^void pubsubCommand(redisClient *c) {$/;"	f
pubsubPattern	.\redis.h	/^typedef struct pubsubPattern {$/;"	s
pubsubPattern	.\redis.h	/^} pubsubPattern;$/;"	t	typeref:struct:pubsubPattern
pubsubPublishMessage	.\pubsub.c	/^int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f
pubsubSubscribeChannel	.\pubsub.c	/^int pubsubSubscribeChannel(redisClient *c, robj *channel) {$/;"	f
pubsubSubscribePattern	.\pubsub.c	/^int pubsubSubscribePattern(redisClient *c, robj *pattern) {$/;"	f
pubsubUnsubscribeAllChannels	.\pubsub.c	/^int pubsubUnsubscribeAllChannels(redisClient *c, int notify) {$/;"	f
pubsubUnsubscribeAllPatterns	.\pubsub.c	/^int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) {$/;"	f
pubsubUnsubscribeChannel	.\pubsub.c	/^int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) {$/;"	f
pubsubUnsubscribePattern	.\pubsub.c	/^int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) {$/;"	f
pubsub_channels	.\redis.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:redisServer
pubsub_channels	.\redis.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient
pubsub_mode	.\redis-cli.c	/^    int pubsub_mode;$/;"	m	struct:config	file:
pubsub_patterns	.\redis.h	/^    list *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	struct:redisServer
pubsub_patterns	.\redis.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient
punsubscribeCommand	.\pubsub.c	/^void punsubscribeCommand(redisClient *c) {$/;"	f
punsubscribebulk	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
pushGenericCommand	.\t_list.c	/^void pushGenericCommand(redisClient *c, int where) {$/;"	f
pushxGenericCommand	.\t_list.c	/^void pushxGenericCommand(redisClient *c, robj *refval, robj *val, int where) {$/;"	f
qsortCompareSetsByCardinality	.\t_set.c	/^int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f
qsortCompareSetsByRevCardinality	.\t_set.c	/^int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {$/;"	f
querybuf	.\redis.h	/^    sds querybuf;$/;"	m	struct:redisClient
querybuf_peak	.\redis.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size *\/$/;"	m	struct:redisClient
queueMultiCommand	.\multi.c	/^void queueMultiCommand(redisClient *c) {$/;"	f
queued	.\redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
quiet	.\redis-benchmark.c	/^    int quiet;$/;"	m	struct:config	file:
quorum	.\sentinel.c	/^    int quorum;         \/* Number of sentinels that need to agree on failure. *\/$/;"	m	struct:sentinelRedisInstance	file:
randfree	.\redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	struct:_client	file:
randlen	.\redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	struct:_client	file:
randomizeClientKey	.\redis-benchmark.c	/^static void randomizeClientKey(client c) {$/;"	f	file:
randomkeyCommand	.\db.c	/^void randomkeyCommand(redisClient *c) {$/;"	f
randomkeys	.\redis-benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:
randomkeys_keyspacelen	.\redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:
randptr	.\redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	struct:_client	file:
randstring	.\ziplist.c	/^int randstring(char *target, unsigned int min, unsigned int max) {$/;"	f
rdbEncodeInteger	.\rdb.c	/^int rdbEncodeInteger(long long value, unsigned char *enc) {$/;"	f
rdbGenericLoadStringObject	.\rdb.c	/^robj *rdbGenericLoadStringObject(rio *rdb, int encode) {$/;"	f
rdbIsObjectType	.\rdb.h	91;"	d
rdbLoad	.\rdb.c	/^int rdbLoad(char *filename) {$/;"	f
rdbLoadDoubleValue	.\rdb.c	/^int rdbLoadDoubleValue(rio *rdb, double *val) {$/;"	f
rdbLoadEncodedStringObject	.\rdb.c	/^robj *rdbLoadEncodedStringObject(rio *rdb) {$/;"	f
rdbLoadIntegerObject	.\rdb.c	/^robj *rdbLoadIntegerObject(rio *rdb, int enctype, int encode) {$/;"	f
rdbLoadLen	.\rdb.c	/^uint32_t rdbLoadLen(rio *rdb, int *isencoded) {$/;"	f
rdbLoadLzfStringObject	.\rdb.c	/^robj *rdbLoadLzfStringObject(rio *rdb) {$/;"	f
rdbLoadMillisecondTime	.\rdb.c	/^long long rdbLoadMillisecondTime(rio *rdb) {$/;"	f
rdbLoadObject	.\rdb.c	/^robj *rdbLoadObject(int rdbtype, rio *rdb) {$/;"	f
rdbLoadObjectType	.\rdb.c	/^int rdbLoadObjectType(rio *rdb) {$/;"	f
rdbLoadProgressCallback	.\rdb.c	/^void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {$/;"	f
rdbLoadStringObject	.\rdb.c	/^robj *rdbLoadStringObject(rio *rdb) {$/;"	f
rdbLoadTime	.\rdb.c	/^time_t rdbLoadTime(rio *rdb) {$/;"	f
rdbLoadType	.\rdb.c	/^int rdbLoadType(rio *rdb) {$/;"	f
rdbRemoveTempFile	.\rdb.c	/^void rdbRemoveTempFile(pid_t childpid) {$/;"	f
rdbSave	.\rdb.c	/^int rdbSave(char *filename) {$/;"	f
rdbSaveBackground	.\rdb.c	/^int rdbSaveBackground(char *filename) {$/;"	f
rdbSaveDoubleValue	.\rdb.c	/^int rdbSaveDoubleValue(rio *rdb, double val) {$/;"	f
rdbSaveKeyValuePair	.\rdb.c	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val,$/;"	f
rdbSaveLen	.\rdb.c	/^int rdbSaveLen(rio *rdb, uint32_t len) {$/;"	f
rdbSaveLongLongAsStringObject	.\rdb.c	/^int rdbSaveLongLongAsStringObject(rio *rdb, long long value) {$/;"	f
rdbSaveLzfStringObject	.\rdb.c	/^int rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {$/;"	f
rdbSaveMillisecondTime	.\rdb.c	/^int rdbSaveMillisecondTime(rio *rdb, long long t) {$/;"	f
rdbSaveObject	.\rdb.c	/^int rdbSaveObject(rio *rdb, robj *o) {$/;"	f
rdbSaveObjectType	.\rdb.c	/^int rdbSaveObjectType(rio *rdb, robj *o) {$/;"	f
rdbSaveRawString	.\rdb.c	/^int rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {$/;"	f
rdbSaveStringObject	.\rdb.c	/^int rdbSaveStringObject(rio *rdb, robj *obj) {$/;"	f
rdbSaveType	.\rdb.c	/^int rdbSaveType(rio *rdb, unsigned char type) {$/;"	f
rdbSavedObjectLen	.\rdb.c	/^off_t rdbSavedObjectLen(robj *o) {$/;"	f
rdbTryIntegerEncoding	.\rdb.c	/^int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {$/;"	f
rdbWriteRaw	.\rdb.c	/^static int rdbWriteRaw(rio *rdb, void *p, size_t len) {$/;"	f	file:
rdb_checksum	.\redis.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	struct:redisServer
rdb_child_pid	.\redis.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	struct:redisServer
rdb_compression	.\redis.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	struct:redisServer
rdb_filename	.\redis-cli.c	/^    char *rdb_filename;$/;"	m	struct:config	file:
rdb_filename	.\redis.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	struct:redisServer
rdb_fsync_range	.\config.h	103;"	d
rdb_fsync_range	.\config.h	105;"	d
rdb_save_time_last	.\redis.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	struct:redisServer
rdb_save_time_start	.\redis.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	struct:redisServer
read	.\rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	struct:_rio
readArgFromStdin	.\redis-cli.c	/^static sds readArgFromStdin(void) {$/;"	f	file:
readArgc	.\redis-check-aof.c	/^int readArgc(FILE *fp, long *target) {$/;"	f
readBytes	.\redis-check-aof.c	/^int readBytes(FILE *fp, char *target, long length) {$/;"	f
readBytes	.\redis-check-dump.c	/^int readBytes(void *target, long num) {$/;"	f
readHandler	.\redis-benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
readLong	.\redis-check-aof.c	/^int readLong(FILE *fp, char prefix, long *target) {$/;"	f
readQueryFromClient	.\networking.c	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
readString	.\redis-check-aof.c	/^int readString(FILE *fp, char** target) {$/;"	f
readSyncBulkPayload	.\replication.c	/^void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
reading	.\sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:
readyList	.\redis.h	/^typedef struct readyList {$/;"	s
readyList	.\redis.h	/^} readyList;$/;"	t	typeref:struct:readyList
ready_keys	.\redis.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	struct:redisDb
ready_keys	.\redis.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	struct:redisServer
realloc	.\zmalloc.c	61;"	d	file:
realloc	.\zmalloc.c	66;"	d	file:
reconnectingInfo	.\redis-cli.c	/^static redisReply *reconnectingInfo(void) {$/;"	f	file:
redisAeAddRead	.\sentinel.c	/^static void redisAeAddRead(void *privdata) {$/;"	f	file:
redisAeAddWrite	.\sentinel.c	/^static void redisAeAddWrite(void *privdata) {$/;"	f	file:
redisAeAttach	.\sentinel.c	/^static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {$/;"	f	file:
redisAeCleanup	.\sentinel.c	/^static void redisAeCleanup(void *privdata) {$/;"	f	file:
redisAeDelRead	.\sentinel.c	/^static void redisAeDelRead(void *privdata) {$/;"	f	file:
redisAeDelWrite	.\sentinel.c	/^static void redisAeDelWrite(void *privdata) {$/;"	f	file:
redisAeEvents	.\sentinel.c	/^typedef struct redisAeEvents {$/;"	s	file:
redisAeEvents	.\sentinel.c	/^} redisAeEvents;$/;"	t	typeref:struct:redisAeEvents	file:
redisAeReadEvent	.\sentinel.c	/^static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
redisAeWriteEvent	.\sentinel.c	/^static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
redisAssert	.\redis.h	365;"	d
redisAssertWithInfo	.\redis.h	364;"	d
redisBuildId	.\release.c	/^uint64_t redisBuildId(void) {$/;"	f
redisClient	.\redis.h	/^typedef struct redisClient {$/;"	s
redisClient	.\redis.h	/^} redisClient;$/;"	t	typeref:struct:redisClient
redisCommand	.\redis.h	/^struct redisCommand {$/;"	s
redisCommandProc	.\redis.h	/^typedef void redisCommandProc(redisClient *c);$/;"	t
redisCommandTable	.\redis.c	/^struct redisCommand redisCommandTable[] = {$/;"	v	typeref:struct:redisCommand
redisDb	.\redis.h	/^typedef struct redisDb {$/;"	s
redisDb	.\redis.h	/^} redisDb;$/;"	t	typeref:struct:redisDb
redisDebug	.\redis.h	1399;"	d
redisDebugMark	.\redis.h	1401;"	d
redisFunctionSym	.\redis.h	/^struct redisFunctionSym {$/;"	s
redisGetKeysProc	.\redis.h	/^typedef int *redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, int *numkeys, int flags);$/;"	t
redisGitDirty	.\release.c	/^char *redisGitDirty(void) {$/;"	f
redisGitSHA1	.\release.c	/^char *redisGitSHA1(void) {$/;"	f
redisLog	.\redis.c	/^void redisLog(int level, const char *fmt, ...) {$/;"	f
redisLogFromHandler	.\redis.c	/^void redisLogFromHandler(int level, const char *msg) {$/;"	f
redisLogHexDump	.\debug.c	/^void redisLogHexDump(int level, char *descr, void *value, size_t len) {$/;"	f
redisLogObjectDebugInfo	.\debug.c	/^void redisLogObjectDebugInfo(robj *o) {$/;"	f
redisLogRaw	.\redis.c	/^void redisLogRaw(int level, const char *msg) {$/;"	f
redisLrand48	.\rand.c	/^int32_t redisLrand48() {$/;"	f
redisObject	.\redis.h	/^typedef struct redisObject {$/;"	s
redisOp	.\redis.h	/^typedef struct redisOp {$/;"	s
redisOp	.\redis.h	/^} redisOp;$/;"	t	typeref:struct:redisOp
redisOpArray	.\redis.h	/^typedef struct redisOpArray {$/;"	s
redisOpArray	.\redis.h	/^} redisOpArray;$/;"	t	typeref:struct:redisOpArray
redisOpArrayAppend	.\redis.c	/^int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,$/;"	f
redisOpArrayFree	.\redis.c	/^void redisOpArrayFree(redisOpArray *oa) {$/;"	f
redisOpArrayInit	.\redis.c	/^void redisOpArrayInit(redisOpArray *oa) {$/;"	f
redisOutOfMemoryHandler	.\redis.c	/^void redisOutOfMemoryHandler(size_t allocation_size) {$/;"	f
redisPanic	.\redis.h	366;"	d
redisPopcount	.\bitops.c	/^size_t redisPopcount(void *s, long count) {$/;"	f
redisProtocolToLuaType	.\scripting.c	/^char *redisProtocolToLuaType(lua_State *lua, char* reply) {$/;"	f
redisProtocolToLuaType_Bulk	.\scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Error	.\scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Int	.\scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_MultiBulk	.\scripting.c	/^char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {$/;"	f
redisProtocolToLuaType_Status	.\scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {$/;"	f
redisServer	.\redis.h	/^struct redisServer {$/;"	s
redisSetProcTitle	.\redis.c	/^void redisSetProcTitle(char *title) {$/;"	f
redisSortObject	.\redis.h	/^} redisSortObject;$/;"	t	typeref:struct:_redisSortObject
redisSortOperation	.\redis.h	/^} redisSortOperation;$/;"	t	typeref:struct:_redisSortOperation
redisSrand48	.\rand.c	/^void redisSrand48(int32_t seedval) {$/;"	f
redis_fstat	.\config.h	39;"	d
redis_fstat	.\config.h	42;"	d
redis_math_random	.\scripting.c	/^int redis_math_random (lua_State *L) {$/;"	f
redis_math_randomseed	.\scripting.c	/^int redis_math_randomseed (lua_State *L) {$/;"	f
redis_stat	.\config.h	40;"	d
redis_stat	.\config.h	43;"	d
refcount	.\redis.h	/^    int refcount;$/;"	m	struct:redisObject
refreshGoodSlavesCount	.\replication.c	/^void refreshGoodSlavesCount(void) {$/;"	f
rehashidx	.\dict.h	/^    int rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict
releaseSentinelAddr	.\sentinel.c	/^void releaseSentinelAddr(sentinelAddr *sa) {$/;"	f
releaseSentinelRedisInstance	.\sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {$/;"	f
removeExpire	.\db.c	/^int removeExpire(redisDb *db, robj *key) {$/;"	f
removeMatchingSentinelsFromMaster	.\sentinel.c	/^int removeMatchingSentinelsFromMaster(sentinelRedisInstance *master, char *ip, int port, char *runid) {$/;"	f
renameCommand	.\db.c	/^void renameCommand(redisClient *c) {$/;"	f
renameGenericCommand	.\db.c	/^void renameGenericCommand(redisClient *c, int nx) {$/;"	f
renameGetKeys	.\db.c	/^int *renameGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys, int flags) {$/;"	f
renamenxCommand	.\db.c	/^void renamenxCommand(redisClient *c) {$/;"	f
repeat	.\redis-cli.c	/^    long repeat;$/;"	m	struct:config	file:
repl	.\redis-cli.c	/^static void repl() {$/;"	f	file:
replScriptCacheDictType	.\redis.c	/^dictType replScriptCacheDictType = {$/;"	v
repl_ack_off	.\redis.h	/^    long long repl_ack_off; \/* replication ack offset, if this is a slave *\/$/;"	m	struct:redisClient
repl_ack_time	.\redis.h	/^    long long repl_ack_time;\/* replication ack time, if this is a slave *\/$/;"	m	struct:redisClient
repl_backlog	.\redis.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	struct:redisServer
repl_backlog_histlen	.\redis.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	struct:redisServer
repl_backlog_idx	.\redis.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	struct:redisServer
repl_backlog_off	.\redis.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	struct:redisServer
repl_backlog_size	.\redis.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	struct:redisServer
repl_backlog_time_limit	.\redis.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	struct:redisServer
repl_disable_tcp_nodelay	.\redis.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	struct:redisServer
repl_down_since	.\redis.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	struct:redisServer
repl_good_slaves_count	.\redis.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	struct:redisServer
repl_master_initial_offset	.\redis.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	struct:redisServer
repl_master_runid	.\redis.h	/^    char repl_master_runid[REDIS_RUN_ID_SIZE+1];  \/* Master run id for PSYNC. *\/$/;"	m	struct:redisServer
repl_min_slaves_max_lag	.\redis.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	struct:redisServer
repl_min_slaves_to_write	.\redis.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	struct:redisServer
repl_no_slaves_since	.\redis.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	struct:redisServer
repl_ping_slave_period	.\redis.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	struct:redisServer
repl_scriptcache_dict	.\redis.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	struct:redisServer
repl_scriptcache_fifo	.\redis.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	struct:redisServer
repl_scriptcache_size	.\redis.h	/^    int repl_scriptcache_size;          \/* Max number of elements. *\/$/;"	m	struct:redisServer
repl_serve_stale_data	.\redis.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	struct:redisServer
repl_slave_ro	.\redis.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	struct:redisServer
repl_state	.\redis.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	struct:redisServer
repl_syncio_timeout	.\redis.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	struct:redisServer
repl_timeout	.\redis.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	struct:redisServer
repl_transfer_fd	.\redis.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	struct:redisServer
repl_transfer_last_fsync_off	.\redis.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	struct:redisServer
repl_transfer_lastio	.\redis.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	struct:redisServer
repl_transfer_read	.\redis.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	struct:redisServer
repl_transfer_s	.\redis.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	struct:redisServer
repl_transfer_size	.\redis.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	struct:redisServer
repl_transfer_tmpfile	.\redis.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	struct:redisServer
replconfCommand	.\replication.c	/^void replconfCommand(redisClient *c) {$/;"	f
repldbfd	.\redis.h	/^    int repldbfd;           \/* replication DB file descriptor *\/$/;"	m	struct:redisClient
repldboff	.\redis.h	/^    off_t repldboff;        \/* replication DB file offset *\/$/;"	m	struct:redisClient
repldbsize	.\redis.h	/^    off_t repldbsize;       \/* replication DB file size *\/$/;"	m	struct:redisClient
replicationAbortSyncTransfer	.\replication.c	/^void replicationAbortSyncTransfer(void) {$/;"	f
replicationCacheMaster	.\replication.c	/^void replicationCacheMaster(redisClient *c) {$/;"	f
replicationCron	.\replication.c	/^void replicationCron(void) {$/;"	f
replicationDiscardCachedMaster	.\replication.c	/^void replicationDiscardCachedMaster(void) {$/;"	f
replicationEmptyDbCallback	.\replication.c	/^void replicationEmptyDbCallback(void *privdata) {$/;"	f
replicationFeedMonitors	.\replication.c	/^void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc) {$/;"	f
replicationFeedSlaves	.\replication.c	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {$/;"	f
replicationHandleMasterDisconnection	.\networking.c	/^void replicationHandleMasterDisconnection(void) {$/;"	f
replicationResurrectCachedMaster	.\replication.c	/^void replicationResurrectCachedMaster(int newfd) {$/;"	f
replicationScriptCacheAdd	.\replication.c	/^void replicationScriptCacheAdd(sds sha1) {$/;"	f
replicationScriptCacheExists	.\replication.c	/^int replicationScriptCacheExists(sds sha1) {$/;"	f
replicationScriptCacheFlush	.\replication.c	/^void replicationScriptCacheFlush(void) {$/;"	f
replicationScriptCacheInit	.\replication.c	/^void replicationScriptCacheInit(void) {$/;"	f
replicationSendAck	.\replication.c	/^void replicationSendAck(void) {$/;"	f
replicationSendNewlineToMaster	.\replication.c	/^void replicationSendNewlineToMaster(void) {$/;"	f
replicationSetMaster	.\replication.c	/^void replicationSetMaster(char *ip, int port) {$/;"	f
replicationUnsetMaster	.\replication.c	/^void replicationUnsetMaster(void) {$/;"	f
reploff	.\redis.h	/^    long long reploff;      \/* replication offset if this is our master *\/$/;"	m	struct:redisClient
replrunid	.\redis.h	/^    char replrunid[REDIS_RUN_ID_SIZE+1]; \/* master run id if this is a master *\/$/;"	m	struct:redisClient
replstate	.\redis.h	/^    int replstate;          \/* replication state if this is a slave *\/$/;"	m	struct:redisClient
reply	.\redis.h	/^    list *reply;$/;"	m	struct:redisClient
reply_bytes	.\redis.h	/^    unsigned long reply_bytes; \/* Tot bytes of objects in reply list *\/$/;"	m	struct:redisClient
reqtype	.\redis.h	/^    int reqtype;$/;"	m	struct:redisClient
requests	.\redis-benchmark.c	/^    int requests;$/;"	m	struct:config	file:
requests_finished	.\redis-benchmark.c	/^    int requests_finished;$/;"	m	struct:config	file:
requests_issued	.\redis-benchmark.c	/^    int requests_issued;$/;"	m	struct:config	file:
requirepass	.\redis.h	/^    char *requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	struct:redisServer
reset	.\setproctitle.c	/^	_Bool reset;$/;"	m	struct:__anon16	file:
resetClient	.\networking.c	/^void resetClient(redisClient *c) {$/;"	f
resetClient	.\redis-benchmark.c	/^static void resetClient(client c) {$/;"	f	file:
resetCommandTableStats	.\redis.c	/^void resetCommandTableStats(void) {$/;"	f
resetRefCount	.\object.c	/^robj *resetRefCount(robj *obj) {$/;"	f
resetServerSaveParams	.\config.c	/^void resetServerSaveParams() {$/;"	f
resizeReplicationBacklog	.\replication.c	/^void resizeReplicationBacklog(long long newsize) {$/;"	f
restoreCommand	.\migrate.c	/^void restoreCommand(redisClient *c) {$/;"	f
retry_num	.\sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	struct:sentinelScriptJob	file:
rev	.\dict.c	/^static unsigned long rev(unsigned long v) {$/;"	f	file:
rewriteAppendOnlyFile	.\aof.c	/^int rewriteAppendOnlyFile(char *filename) {$/;"	f
rewriteAppendOnlyFileBackground	.\aof.c	/^int rewriteAppendOnlyFileBackground(void) {$/;"	f
rewriteClientCommandArgument	.\networking.c	/^void rewriteClientCommandArgument(redisClient *c, int i, robj *newval) {$/;"	f
rewriteClientCommandVector	.\networking.c	/^void rewriteClientCommandVector(redisClient *c, int argc, ...) {$/;"	f
rewriteConfig	.\config.c	/^int rewriteConfig(char *path) {$/;"	f
rewriteConfigAddLineNumberToOption	.\config.c	/^void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {$/;"	f
rewriteConfigAppendLine	.\config.c	/^void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {$/;"	f
rewriteConfigBindOption	.\config.c	/^void rewriteConfigBindOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigBytesOption	.\config.c	/^void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f
rewriteConfigClientoutputbufferlimitOption	.\config.c	/^void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigDirOption	.\config.c	/^void rewriteConfigDirOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigEnumOption	.\config.c	/^void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, ...) {$/;"	f
rewriteConfigFormatMemory	.\config.c	/^int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {$/;"	f
rewriteConfigGetContentFromState	.\config.c	/^sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {$/;"	f
rewriteConfigMarkAsProcessed	.\config.c	/^void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, char *option) {$/;"	f
rewriteConfigNotifykeyspaceeventsOption	.\config.c	/^void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigNumericalOption	.\config.c	/^void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f
rewriteConfigOctalOption	.\config.c	/^void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f
rewriteConfigOverwriteFile	.\config.c	/^int rewriteConfigOverwriteFile(char *configfile, sds content) {$/;"	f
rewriteConfigReadOldFile	.\config.c	/^struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {$/;"	f
rewriteConfigReleaseState	.\config.c	/^void rewriteConfigReleaseState(struct rewriteConfigState *state) {$/;"	f
rewriteConfigRemoveOrphaned	.\config.c	/^void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {$/;"	f
rewriteConfigRewriteLine	.\config.c	/^void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force) {$/;"	f
rewriteConfigSaveOption	.\config.c	/^void rewriteConfigSaveOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigSentinelOption	.\sentinel.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigSlaveofOption	.\config.c	/^void rewriteConfigSlaveofOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigState	.\config.c	/^struct rewriteConfigState {$/;"	s	file:
rewriteConfigStringOption	.\config.c	/^void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {$/;"	f
rewriteConfigSyslogfacilityOption	.\config.c	/^void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigYesNoOption	.\config.c	/^void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f
rewriteHashObject	.\aof.c	/^int rewriteHashObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteListObject	.\aof.c	/^int rewriteListObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteSetObject	.\aof.c	/^int rewriteSetObject(rio *r, robj *key, robj *o) {$/;"	f
rewriteSortedSetObject	.\aof.c	/^int rewriteSortedSetObject(rio *r, robj *key, robj *o) {$/;"	f
rewritten	.\config.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	struct:rewriteConfigState	file:
rfds	.\ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	.\ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
rio	.\rio.h	/^typedef struct _rio rio;$/;"	t	typeref:struct:_rio
rioBufferIO	.\rio.c	/^static const rio rioBufferIO = {$/;"	v	file:
rioBufferRead	.\rio.c	/^static size_t rioBufferRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioBufferTell	.\rio.c	/^static off_t rioBufferTell(rio *r) {$/;"	f	file:
rioBufferWrite	.\rio.c	/^static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioFileIO	.\rio.c	/^static const rio rioFileIO = {$/;"	v	file:
rioFileRead	.\rio.c	/^static size_t rioFileRead(rio *r, void *buf, size_t len) {$/;"	f	file:
rioFileTell	.\rio.c	/^static off_t rioFileTell(rio *r) {$/;"	f	file:
rioFileWrite	.\rio.c	/^static size_t rioFileWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:
rioGenericUpdateChecksum	.\rio.c	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {$/;"	f
rioInitWithBuffer	.\rio.c	/^void rioInitWithBuffer(rio *r, sds s) {$/;"	f
rioInitWithFile	.\rio.c	/^void rioInitWithFile(rio *r, FILE *fp) {$/;"	f
rioRead	.\rio.h	/^static inline size_t rioRead(rio *r, void *buf, size_t len) {$/;"	f
rioSetAutoSync	.\rio.c	/^void rioSetAutoSync(rio *r, off_t bytes) {$/;"	f
rioTell	.\rio.h	/^static inline off_t rioTell(rio *r) {$/;"	f
rioWrite	.\rio.h	/^static inline size_t rioWrite(rio *r, const void *buf, size_t len) {$/;"	f
rioWriteBulkCount	.\rio.c	/^size_t rioWriteBulkCount(rio *r, char prefix, int count) {$/;"	f
rioWriteBulkDouble	.\rio.c	/^size_t rioWriteBulkDouble(rio *r, double d) {$/;"	f
rioWriteBulkLongLong	.\rio.c	/^size_t rioWriteBulkLongLong(rio *r, long long l) {$/;"	f
rioWriteBulkObject	.\aof.c	/^int rioWriteBulkObject(rio *r, robj *obj) {$/;"	f
rioWriteBulkString	.\rio.c	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {$/;"	f
rioWriteHashIteratorCursor	.\aof.c	/^static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {$/;"	f	file:
robj	.\redis.h	/^} robj;$/;"	t	typeref:struct:redisObject
rol	.\sha1.c	33;"	d	file:
role_reported	.\sentinel.c	/^    int role_reported;$/;"	m	struct:sentinelRedisInstance	file:
role_reported_time	.\sentinel.c	/^    mstime_t role_reported_time;$/;"	m	struct:sentinelRedisInstance	file:
roslaveerr	.\redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
rpop	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
rpopCommand	.\redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,*rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::
rpopCommand	.\t_list.c	/^void rpopCommand(redisClient *c) {$/;"	f
rpoplpushCommand	.\t_list.c	/^void rpoplpushCommand(redisClient *c) {$/;"	f
rpoplpushHandlePush	.\t_list.c	/^void rpoplpushHandlePush(redisClient *c, robj *dstkey, robj *dstobj, robj *value) {$/;"	f
rpushCommand	.\t_list.c	/^void rpushCommand(redisClient *c) {$/;"	f
rpushxCommand	.\t_list.c	/^void rpushxCommand(redisClient *c) {$/;"	f
run_with_period	.\redis.h	360;"	d
runid	.\redis.h	/^    char runid[REDIS_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	struct:redisServer
runid	.\sentinel.c	/^    char *runid;    \/* run ID of this instance. *\/$/;"	m	struct:sentinelRedisInstance	file:
runid	.\sentinel.c	/^    char *runid;$/;"	m	struct:sentinelLeader	file:
running_scripts	.\sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	struct:sentinelState	file:
s64	.\dict.h	/^        int64_t s64;$/;"	m	union:dictEntry::__anon2
s_down_since_time	.\sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:
saddCommand	.\t_set.c	/^void saddCommand(redisClient *c) {$/;"	f
safe	.\dict.h	/^    int table, index, safe;$/;"	m	struct:dictIterator
sameobjecterr	.\redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
saveCommand	.\rdb.c	/^void saveCommand(redisClient *c) {$/;"	f
saveparam	.\redis.h	/^struct saveparam {$/;"	s
saveparams	.\redis.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::saveparam
saveparamslen	.\redis.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	struct:redisServer
scanCallback	.\db.c	/^void scanCallback(void *privdata, const dictEntry *de) {$/;"	f
scanCommand	.\db.c	/^void scanCommand(redisClient *c) {$/;"	f
scanGenericCommand	.\db.c	/^void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor) {$/;"	f
scardCommand	.\t_set.c	/^void scardCommand(redisClient *c) {$/;"	f
score	.\redis.h	/^        double score;$/;"	m	union:_redisSortObject::__anon7
score	.\redis.h	/^    double score;$/;"	m	struct:zskiplistNode
score	.\t_zset.c	/^    double score;$/;"	m	struct:__anon24	file:
scriptCommand	.\scripting.c	/^void scriptCommand(redisClient *c) {$/;"	f
scriptingEnableGlobalsProtection	.\scripting.c	/^void scriptingEnableGlobalsProtection(lua_State *lua) {$/;"	f
scriptingInit	.\scripting.c	/^void scriptingInit(void) {$/;"	f
scriptingRelease	.\scripting.c	/^void scriptingRelease(void) {$/;"	f
scriptingReset	.\scripting.c	/^void scriptingReset(void) {$/;"	f
scripts_queue	.\sentinel.c	/^    list *scripts_queue;    \/* Queue of user scripts to execute. *\/$/;"	m	struct:sentinelState	file:
sdiffCommand	.\t_set.c	/^void sdiffCommand(redisClient *c) {$/;"	f
sdiffstoreCommand	.\t_set.c	/^void sdiffstoreCommand(redisClient *c) {$/;"	f
sds	.\sds.h	/^typedef char *sds;$/;"	t
sdsAllocSize	.\sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsIncrLen	.\sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	.\sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	.\sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsavail	.\sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	.\sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	.\sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	.\sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	.\sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	.\sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	.\sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	.\sds.c	/^void sdsclear(sds s) {$/;"	f
sdscmp	.\sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	.\sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	.\sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	.\sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	.\sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	.\sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	.\sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	.\sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	.\sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr	.\sds.h	/^struct sdshdr {$/;"	s
sdsjoin	.\sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdslen	.\sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsmapchars	.\sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	.\sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	.\sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	.\sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	.\sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	.\sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	.\sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	.\sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	.\sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	.\sds.c	/^void sdsupdatelen(sds s) {$/;"	f
seconds	.\redis.h	/^    time_t seconds;$/;"	m	struct:saveparam
select	.\redis.h	/^    *select[REDIS_SHARED_SELECT_CMDS],$/;"	m	struct:sharedObjectsStruct
selectCommand	.\db.c	/^void selectCommand(redisClient *c) {$/;"	f
selectDb	.\db.c	/^int selectDb(redisClient *c, int id) {$/;"	f
selectlen	.\redis-benchmark.c	/^    int selectlen;  \/* If non-zero, a SELECT of 'selectlen' bytes is currently$/;"	m	struct:_client	file:
sendBulkToSlave	.\replication.c	/^void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
sendReplyToClient	.\networking.c	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
sendSync	.\redis-cli.c	/^unsigned long long sendSync(int fd) {$/;"	f
sendSynchronousCommand	.\replication.c	/^char *sendSynchronousCommand(int fd, ...) {$/;"	f
sentinel	.\sentinel.c	/^} sentinel;$/;"	v	typeref:struct:sentinelState
sentinelAbortFailover	.\sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri) {$/;"	f
sentinelAddFlagsToDictOfRedisInstances	.\sentinel.c	/^void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f
sentinelAddr	.\sentinel.c	/^typedef struct sentinelAddr {$/;"	s	file:
sentinelAddr	.\sentinel.c	/^} sentinelAddr;$/;"	t	typeref:struct:sentinelAddr	file:
sentinelAddrIsEqual	.\sentinel.c	/^int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {$/;"	f
sentinelAskMasterStateToOtherSentinels	.\sentinel.c	/^void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {$/;"	f
sentinelCallClientReconfScript	.\sentinel.c	/^void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {$/;"	f
sentinelCheckObjectivelyDown	.\sentinel.c	/^void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {$/;"	f
sentinelCheckSubjectivelyDown	.\sentinel.c	/^void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {$/;"	f
sentinelCheckTiltCondition	.\sentinel.c	/^void sentinelCheckTiltCondition(void) {$/;"	f
sentinelCollectTerminatedScripts	.\sentinel.c	/^void sentinelCollectTerminatedScripts(void) {$/;"	f
sentinelCommand	.\sentinel.c	/^void sentinelCommand(redisClient *c) {$/;"	f
sentinelDelFlagsToDictOfRedisInstances	.\sentinel.c	/^void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f
sentinelDiscardReplyCallback	.\sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelDisconnectCallback	.\sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {$/;"	f
sentinelDisconnectInstanceFromContext	.\sentinel.c	/^void sentinelDisconnectInstanceFromContext(const redisAsyncContext *c) {$/;"	f
sentinelEvent	.\sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,$/;"	f
sentinelFailoverDetectEnd	.\sentinel.c	/^void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverReconfNextSlave	.\sentinel.c	/^void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverSelectSlave	.\sentinel.c	/^void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverSendSlaveOfNoOne	.\sentinel.c	/^void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverStateMachine	.\sentinel.c	/^void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverStateStr	.\sentinel.c	/^const char *sentinelFailoverStateStr(int state) {$/;"	f
sentinelFailoverSwitchToPromotedSlave	.\sentinel.c	/^void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {$/;"	f
sentinelFailoverWaitPromotion	.\sentinel.c	/^void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {$/;"	f
sentinelFailoverWaitStart	.\sentinel.c	/^void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {$/;"	f
sentinelFlushConfig	.\sentinel.c	/^void sentinelFlushConfig(void) {$/;"	f
sentinelGetCurrentMasterAddress	.\sentinel.c	/^sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {$/;"	f
sentinelGetLeader	.\sentinel.c	/^char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {$/;"	f
sentinelGetMasterByName	.\sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name) {$/;"	f
sentinelGetMasterByNameOrReplyError	.\sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(redisClient *c,$/;"	f
sentinelGetScriptListNodeByPid	.\sentinel.c	/^listNode *sentinelGetScriptListNodeByPid(pid_t pid) {$/;"	f
sentinelHandleConfiguration	.\sentinel.c	/^char *sentinelHandleConfiguration(char **argv, int argc) {$/;"	f
sentinelHandleDictOfRedisInstances	.\sentinel.c	/^void sentinelHandleDictOfRedisInstances(dict *instances) {$/;"	f
sentinelHandleRedisInstance	.\sentinel.c	/^void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {$/;"	f
sentinelInfoCommand	.\sentinel.c	/^void sentinelInfoCommand(redisClient *c) {$/;"	f
sentinelInfoReplyCallback	.\sentinel.c	/^void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelIsRunning	.\sentinel.c	/^void sentinelIsRunning(void) {$/;"	f
sentinelKillLink	.\sentinel.c	/^void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f
sentinelKillTimedoutScripts	.\sentinel.c	/^void sentinelKillTimedoutScripts(void) {$/;"	f
sentinelLeader	.\sentinel.c	/^struct sentinelLeader {$/;"	s	file:
sentinelLeaderIncr	.\sentinel.c	/^int sentinelLeaderIncr(dict *counters, char *runid) {$/;"	f
sentinelLinkEstablishedCallback	.\sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {$/;"	f
sentinelMasterLooksSane	.\sentinel.c	/^int sentinelMasterLooksSane(sentinelRedisInstance *master) {$/;"	f
sentinelPendingScriptsCommand	.\sentinel.c	/^void sentinelPendingScriptsCommand(redisClient *c) {$/;"	f
sentinelPingInstance	.\sentinel.c	/^void sentinelPingInstance(sentinelRedisInstance *ri) {$/;"	f
sentinelPingReplyCallback	.\sentinel.c	/^void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelPublishReplyCallback	.\sentinel.c	/^void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReceiveHelloMessages	.\sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReceiveIsMasterDownReply	.\sentinel.c	/^void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f
sentinelReconnectInstance	.\sentinel.c	/^void sentinelReconnectInstance(sentinelRedisInstance *ri) {$/;"	f
sentinelRedisInstance	.\sentinel.c	/^typedef struct sentinelRedisInstance {$/;"	s	file:
sentinelRedisInstance	.\sentinel.c	/^} sentinelRedisInstance;$/;"	t	typeref:struct:sentinelRedisInstance	file:
sentinelRedisInstanceLookupSlave	.\sentinel.c	/^sentinelRedisInstance *sentinelRedisInstanceLookupSlave($/;"	f
sentinelRedisInstanceNoDownFor	.\sentinel.c	/^int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {$/;"	f
sentinelRedisInstanceTypeStr	.\sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {$/;"	f
sentinelRefreshInstanceInfo	.\sentinel.c	/^void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {$/;"	f
sentinelReleaseScriptJob	.\sentinel.c	/^void sentinelReleaseScriptJob(sentinelScriptJob *sj) {$/;"	f
sentinelResetMaster	.\sentinel.c	/^void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {$/;"	f
sentinelResetMasterAndChangeAddress	.\sentinel.c	/^int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {$/;"	f
sentinelResetMastersByPattern	.\sentinel.c	/^int sentinelResetMastersByPattern(char *pattern, int flags) {$/;"	f
sentinelRunPendingScripts	.\sentinel.c	/^void sentinelRunPendingScripts(void) {$/;"	f
sentinelScheduleScriptExecution	.\sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...) {$/;"	f
sentinelScriptJob	.\sentinel.c	/^typedef struct sentinelScriptJob {$/;"	s	file:
sentinelScriptJob	.\sentinel.c	/^} sentinelScriptJob;$/;"	t	typeref:struct:sentinelScriptJob	file:
sentinelScriptRetryDelay	.\sentinel.c	/^mstime_t sentinelScriptRetryDelay(int retry_num) {$/;"	f
sentinelSelectSlave	.\sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {$/;"	f
sentinelSendAuthIfNeeded	.\sentinel.c	/^void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f
sentinelSendHello	.\sentinel.c	/^int sentinelSendHello(sentinelRedisInstance *ri) {$/;"	f
sentinelSendSlaveOf	.\sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {$/;"	f
sentinelStartFailover	.\sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master) {$/;"	f
sentinelStartFailoverIfNeeded	.\sentinel.c	/^int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {$/;"	f
sentinelState	.\sentinel.c	/^struct sentinelState {$/;"	s	file:
sentinelTimer	.\sentinel.c	/^void sentinelTimer(void) {$/;"	f
sentinelVoteLeader	.\sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {$/;"	f
sentinel_mode	.\redis.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	struct:redisServer
sentinelcmds	.\sentinel.c	/^struct redisCommand sentinelcmds[] = {$/;"	v	typeref:struct:redisCommand
sentinels	.\sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	struct:sentinelRedisInstance	file:
sentlen	.\redis.h	/^    int sentlen;            \/* Amount of bytes already sent in the current$/;"	m	struct:redisClient
serveClientBlockedOnList	.\t_list.c	/^int serveClientBlockedOnList(redisClient *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)$/;"	f
server	.\redis.c	/^struct redisServer server; \/* server global state *\/$/;"	v	typeref:struct:redisServer
serverCron	.\redis.c	/^int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
set	.\t_zset.c	/^        } set;$/;"	m	union:__anon18::__anon19	typeref:union:__anon18::__anon19::_iterset	file:
setCommand	.\t_string.c	/^void setCommand(redisClient *c) {$/;"	f
setDeferredMultiBulkLength	.\networking.c	/^void setDeferredMultiBulkLength(redisClient *c, void *node, long length) {$/;"	f
setDictType	.\redis.c	/^dictType setDictType = {$/;"	v
setExpire	.\db.c	/^void setExpire(redisDb *db, robj *key, long long when) {$/;"	f
setGenericCommand	.\t_string.c	/^void setGenericCommand(redisClient *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {$/;"	f
setKey	.\db.c	/^void setKey(redisDb *db, robj *key, robj *val) {$/;"	f
setProtocolError	.\networking.c	/^static void setProtocolError(redisClient *c, int pos) {$/;"	f	file:
setTypeAdd	.\t_set.c	/^int setTypeAdd(robj *subject, robj *value) {$/;"	f
setTypeConvert	.\t_set.c	/^void setTypeConvert(robj *setobj, int enc) {$/;"	f
setTypeCreate	.\t_set.c	/^robj *setTypeCreate(robj *value) {$/;"	f
setTypeInitIterator	.\t_set.c	/^setTypeIterator *setTypeInitIterator(robj *subject) {$/;"	f
setTypeIsMember	.\t_set.c	/^int setTypeIsMember(robj *subject, robj *value) {$/;"	f
setTypeIterator	.\redis.h	/^} setTypeIterator;$/;"	t	typeref:struct:__anon10
setTypeNext	.\t_set.c	/^int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele) {$/;"	f
setTypeNextObject	.\t_set.c	/^robj *setTypeNextObject(setTypeIterator *si) {$/;"	f
setTypeRandomElement	.\t_set.c	/^int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele) {$/;"	f
setTypeReleaseIterator	.\t_set.c	/^void setTypeReleaseIterator(setTypeIterator *si) {$/;"	f
setTypeRemove	.\t_set.c	/^int setTypeRemove(robj *setobj, robj *value) {$/;"	f
setTypeSize	.\t_set.c	/^unsigned long setTypeSize(robj *subject) {$/;"	f
set_max_intset_entries	.\redis.h	/^    size_t set_max_intset_entries;$/;"	m	struct:redisServer
setbitCommand	.\bitops.c	/^void setbitCommand(redisClient *c) {$/;"	f
setexCommand	.\t_string.c	/^void setexCommand(redisClient *c) {$/;"	f
setnxCommand	.\t_string.c	/^void setnxCommand(redisClient *c) {$/;"	f
setproctitle	.\setproctitle.c	/^void setproctitle(const char *fmt, ...) {$/;"	f
setrangeCommand	.\t_string.c	/^void setrangeCommand(redisClient *c) {$/;"	f
setsize	.\ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop
setupSignalHandlers	.\redis.c	/^void setupSignalHandlers(void) {$/;"	f
sflags	.\redis.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:redisCommand
sha1hex	.\scripting.c	/^void sha1hex(char *digest, char *script, size_t len) {$/;"	f
shaScriptObjectDictType	.\redis.c	/^dictType shaScriptObjectDictType = {$/;"	v
shared	.\redis.c	/^struct sharedObjectsStruct shared;$/;"	v	typeref:struct:sharedObjectsStruct
sharedObjectsStruct	.\redis.h	/^struct sharedObjectsStruct {$/;"	s
showLatencyReport	.\redis-benchmark.c	/^static void showLatencyReport(void) {$/;"	f	file:
showThroughput	.\redis-benchmark.c	/^int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
shutdown	.\redis-cli.c	/^    int shutdown;$/;"	m	struct:config	file:
shutdownCommand	.\db.c	/^void shutdownCommand(redisClient *c) {$/;"	f
shutdown_asap	.\redis.h	/^    int shutdown_asap;          \/* SHUTDOWN needed ASAP *\/$/;"	m	struct:redisServer
signalFlushedDb	.\db.c	/^void signalFlushedDb(int dbid) {$/;"	f
signalListAsReady	.\t_list.c	/^void signalListAsReady(redisClient *c, robj *key) {$/;"	f
signalModifiedKey	.\db.c	/^void signalModifiedKey(redisDb *db, robj *key) {$/;"	f
sigsegvHandler	.\debug.c	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret) {$/;"	f
sigtermHandler	.\redis.c	/^static void sigtermHandler(int sig) {$/;"	f	file:
since	.\help.h	/^  char *since;$/;"	m	struct:commandHelp
sinterCommand	.\t_set.c	/^void sinterCommand(redisClient *c) {$/;"	f
sinterGenericCommand	.\t_set.c	/^void sinterGenericCommand(redisClient *c, robj **setkeys, unsigned long setnum, robj *dstkey) {$/;"	f
sinterstoreCommand	.\t_set.c	/^void sinterstoreCommand(redisClient *c) {$/;"	f
sismemberCommand	.\t_set.c	/^void sismemberCommand(redisClient *c) {$/;"	f
size	.\dict.h	/^    unsigned long size;$/;"	m	struct:dictht
size	.\redis-check-dump.c	/^    size_t size;$/;"	m	struct:__anon3	file:
sizemask	.\dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht
sl	.\t_zset.c	/^            } sl;$/;"	m	union:__anon18::__anon19::_iterzset	typeref:struct:__anon18::__anon19::_iterzset::__anon23	file:
slaveMode	.\redis-cli.c	/^static void slaveMode(void) {$/;"	f	file:
slaveTryPartialResynchronization	.\replication.c	/^int slaveTryPartialResynchronization(int fd) {$/;"	f
slave_conf_change_time	.\sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_listening_port	.\redis.h	/^    int slave_listening_port; \/* As configured with: SLAVECONF listening-port *\/$/;"	m	struct:redisClient
slave_master_host	.\sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_master_link_status	.\sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_master_port	.\sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_mode	.\redis-cli.c	/^    int slave_mode;$/;"	m	struct:config	file:
slave_priority	.\redis.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	struct:redisServer
slave_priority	.\sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_reconf_sent_time	.\sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	struct:sentinelRedisInstance	file:
slave_repl_offset	.\sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	struct:sentinelRedisInstance	file:
slaveofCommand	.\replication.c	/^void slaveofCommand(redisClient *c) {$/;"	f
slaves	.\redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer
slaves	.\sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	struct:sentinelRedisInstance	file:
slaveseldb	.\redis.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	struct:redisServer
slowlog	.\redis.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	struct:redisServer
slowlogCommand	.\slowlog.c	/^void slowlogCommand(redisClient *c) {$/;"	f
slowlogCreateEntry	.\slowlog.c	/^slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {$/;"	f
slowlogEntry	.\slowlog.h	/^typedef struct slowlogEntry {$/;"	s
slowlogEntry	.\slowlog.h	/^} slowlogEntry;$/;"	t	typeref:struct:slowlogEntry
slowlogFreeEntry	.\slowlog.c	/^void slowlogFreeEntry(void *septr) {$/;"	f
slowlogInit	.\slowlog.c	/^void slowlogInit(void) {$/;"	f
slowlogPushEntryIfNeeded	.\slowlog.c	/^void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration) {$/;"	f
slowlogReset	.\slowlog.c	/^void slowlogReset(void) {$/;"	f
slowlog_entry_id	.\redis.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	struct:redisServer
slowlog_log_slower_than	.\redis.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	struct:redisServer
slowlog_max_len	.\redis.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	struct:redisServer
slowscripterr	.\redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
smoveCommand	.\t_set.c	/^void smoveCommand(redisClient *c) {$/;"	f
sofd	.\redis.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	struct:redisServer
soft_limit_bytes	.\redis.h	/^    unsigned long long soft_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
soft_limit_seconds	.\redis.h	/^    time_t soft_limit_seconds;$/;"	m	struct:clientBufferLimitsConfig
sortCommand	.\sort.c	/^void sortCommand(redisClient *c) {$/;"	f
sortCompare	.\sort.c	/^int sortCompare(const void *s1, const void *s2) {$/;"	f
sort_alpha	.\redis.h	/^    int sort_alpha;$/;"	m	struct:redisServer
sort_bypattern	.\redis.h	/^    int sort_bypattern;$/;"	m	struct:redisServer
sort_desc	.\redis.h	/^    int sort_desc;$/;"	m	struct:redisServer
sort_store	.\redis.h	/^    int sort_store;$/;"	m	struct:redisServer
space	.\redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
span	.\redis.h	/^        unsigned int span;$/;"	m	struct:zskiplistNode::zskiplistLevel
spopCommand	.\t_set.c	/^void spopCommand(redisClient *c) {$/;"	f
spt_clearenv	.\setproctitle.c	/^static int spt_clearenv(void) {$/;"	f	file:
spt_copyargs	.\setproctitle.c	/^static int spt_copyargs(int argc, char *argv[]) {$/;"	f	file:
spt_copyenv	.\setproctitle.c	/^static int spt_copyenv(char *oldenv[]) {$/;"	f	file:
spt_init	.\setproctitle.c	/^void spt_init(int argc, char *argv[]) {$/;"	f
spt_min	.\setproctitle.c	/^static inline size_t spt_min(size_t a, size_t b) {$/;"	f	file:
sptr	.\t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon18::__anon19::_iterzset::__anon22	file:
srandmemberCommand	.\t_set.c	/^void srandmemberCommand(redisClient *c) {$/;"	f
srandmemberWithCountCommand	.\t_set.c	/^void srandmemberWithCountCommand(redisClient *c) {$/;"	f
sremCommand	.\t_set.c	/^void sremCommand(redisClient *c) {$/;"	f
sscanCommand	.\t_set.c	/^void sscanCommand(redisClient *c) {$/;"	f
start	.\redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	struct:_client	file:
start	.\redis-benchmark.c	/^    long long start;$/;"	m	struct:config	file:
startAppendOnly	.\aof.c	/^int startAppendOnly(void) {$/;"	f
startLoading	.\rdb.c	/^void startLoading(FILE *fp) {$/;"	f
start_time	.\sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	struct:sentinelScriptJob	file:
statMode	.\redis-cli.c	/^static void statMode() {$/;"	f	file:
stat_evictedkeys	.\redis.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	struct:redisServer
stat_expiredkeys	.\redis.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	struct:redisServer
stat_fork_time	.\redis.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	struct:redisServer
stat_keyspace_hits	.\redis.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	struct:redisServer
stat_keyspace_misses	.\redis.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	struct:redisServer
stat_mode	.\redis-cli.c	/^    int stat_mode;$/;"	m	struct:config	file:
stat_numcommands	.\redis.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	struct:redisServer
stat_numconnections	.\redis.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	struct:redisServer
stat_peak_memory	.\redis.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	struct:redisServer
stat_rejected_conn	.\redis.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	struct:redisServer
stat_starttime	.\redis.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	struct:redisServer
stat_sync_full	.\redis.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	struct:redisServer
stat_sync_partial_err	.\redis.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	struct:redisServer
stat_sync_partial_ok	.\redis.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	struct:redisServer
state	.\sha1.h	/^    u_int32_t state[5];$/;"	m	struct:__anon17
stdinarg	.\redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	struct:config	file:
stop	.\ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
stopAppendOnly	.\aof.c	/^void stopAppendOnly(void) {$/;"	f
stopLoading	.\rdb.c	/^void stopLoading(void) {$/;"	f
stop_writes_on_bgsave_err	.\redis.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	struct:redisServer
strEncoding	.\object.c	/^char *strEncoding(int encoding) {$/;"	f
stress	.\ziplist.c	/^void stress(int pos, int num, int maxsize, int dnum) {$/;"	f
string2l	.\util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f
string2ll	.\util.c	/^int string2ll(const char *s, size_t slen, long long *value) {$/;"	f
stringObjectLen	.\object.c	/^size_t stringObjectLen(robj *o) {$/;"	f
stringmatch	.\util.c	/^int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f
stringmatchlen	.\util.c	/^int stringmatchlen(const char *pattern, int patternLen,$/;"	f
strlenCommand	.\t_string.c	/^void strlenCommand(redisClient *c) {$/;"	f
subject	.\redis.h	/^    robj *subject;$/;"	m	struct:__anon10
subject	.\redis.h	/^    robj *subject;$/;"	m	struct:__anon11
subject	.\redis.h	/^    robj *subject;$/;"	m	struct:__anon8
subject	.\t_zset.c	/^    robj *subject;$/;"	m	struct:__anon18	file:
subscribeCommand	.\pubsub.c	/^void subscribeCommand(redisClient *c) {$/;"	f
subscribebulk	.\redis.h	/^    *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
success	.\redis-check-dump.c	/^    char success;$/;"	m	struct:__anon5	file:
summary	.\help.h	/^  char *summary;$/;"	m	struct:commandHelp
sunionCommand	.\t_set.c	/^void sunionCommand(redisClient *c) {$/;"	f
sunionDiffGenericCommand	.\t_set.c	/^void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op) {$/;"	f
sunionstoreCommand	.\t_set.c	/^void sunionstoreCommand(redisClient *c) {$/;"	f
swap	.\pqsort.c	78;"	d	file:
swapcode	.\pqsort.c	54;"	d	file:
swapfunc	.\pqsort.c	/^swapfunc(char *a, char *b, size_t n, int swaptype)$/;"	f	file:
syncCommand	.\replication.c	/^void syncCommand(redisClient *c) {$/;"	f
syncRead	.\syncio.c	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
syncReadLine	.\syncio.c	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
syncWithMaster	.\replication.c	/^void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
syncWrite	.\syncio.c	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f
syntaxerr	.\redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
syslog_enabled	.\redis.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	struct:redisServer
syslog_facility	.\redis.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	struct:redisServer
syslog_ident	.\redis.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	struct:redisServer
table	.\dict.h	/^    dictEntry **table;$/;"	m	struct:dictht
table	.\dict.h	/^    int table, index, safe;$/;"	m	struct:dictIterator
tail	.\adlist.h	/^    listNode *tail;$/;"	m	struct:list
tail	.\redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::
target	.\redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
target	.\redis.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	struct:blockingState
tcpkeepalive	.\redis.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	struct:redisServer
tell	.\rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	struct:_rio
test_cond	.\testhelp.h	44;"	d
test_is_selected	.\redis-benchmark.c	/^int test_is_selected(char *name) {$/;"	f
test_report	.\testhelp.h	48;"	d
test_string2l	.\util.c	/^void test_string2l(void) {$/;"	f
test_string2ll	.\util.c	/^void test_string2ll(void) {$/;"	f
tests	.\redis-benchmark.c	/^    char *tests;$/;"	m	struct:config	file:
tilt	.\sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	struct:sentinelState	file:
tilt_start_time	.\sentinel.c	/^    mstime_t tilt_start_time;   \/* When TITL started. *\/$/;"	m	struct:sentinelState	file:
time	.\bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	struct:bio_job	file:
time	.\slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	struct:slowlogEntry
timeCommand	.\redis.c	/^void timeCommand(redisClient *c) {$/;"	f
timeEventHead	.\ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	.\ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeInMilliseconds	.\dict.c	/^long long timeInMilliseconds(void) {$/;"	f
timeProc	.\ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
time_independent_strcmp	.\redis.c	/^int time_independent_strcmp(char *a, char *b) {$/;"	f
timeout	.\redis.h	/^    time_t timeout;         \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:blockingState
title	.\redis-benchmark.c	/^    const char *title;$/;"	m	struct:config	file:
totlatency	.\redis-benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:
touchWatchedKey	.\multi.c	/^void touchWatchedKey(redisDb *db, robj *key) {$/;"	f
touchWatchedKeysOnFlush	.\multi.c	/^void touchWatchedKeysOnFlush(int dbid) {$/;"	f
trackOperationsPerSecond	.\redis.c	/^void trackOperationsPerSecond(void) {$/;"	f
tryObjectEncoding	.\object.c	/^robj *tryObjectEncoding(robj *o) {$/;"	f
tryResizeHashTables	.\redis.c	/^void tryResizeHashTables(int dbid) {$/;"	f
ttlCommand	.\db.c	/^void ttlCommand(redisClient *c) {$/;"	f
ttlGenericCommand	.\db.c	/^void ttlGenericCommand(redisClient *c, int output_ms) {$/;"	f
type	.\dict.h	/^    dictType *type;$/;"	m	struct:dict
type	.\redis-check-dump.c	/^    int type;$/;"	m	struct:__anon5	file:
type	.\redis-cli.c	/^    int type;$/;"	m	struct:__anon6	file:
type	.\redis.h	/^    int type;$/;"	m	struct:_redisSortOperation
type	.\redis.h	/^    unsigned type:4;$/;"	m	struct:redisObject
type	.\t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	struct:__anon18	file:
typeCommand	.\db.c	/^void typeCommand(redisClient *c) {$/;"	f
types	.\redis-check-dump.c	/^static char types[256][16];$/;"	v	file:
u	.\redis.h	/^    } u;$/;"	m	struct:_redisSortObject	typeref:union:_redisSortObject::__anon7
u16	.\lzfP.h	/^    typedef unsigned int u16;$/;"	t
u16	.\lzfP.h	/^    typedef unsigned short u16;$/;"	t
u64	.\dict.h	/^        uint64_t u64;$/;"	m	union:dictEntry::__anon2
u8	.\lzfP.h	/^typedef unsigned char u8;$/;"	t
u_int	.\solarisfixes.h	48;"	d
u_int32_t	.\solarisfixes.h	49;"	d
unblockClientWaitingData	.\t_list.c	/^void unblockClientWaitingData(redisClient *c) {$/;"	f
unblocked_clients	.\redis.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	struct:redisServer
undoConnectWithMaster	.\replication.c	/^void undoConnectWithMaster(void) {$/;"	f
unixsocket	.\redis.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	struct:redisServer
unixsocketperm	.\redis.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	struct:redisServer
unixtime	.\redis.h	/^    time_t unixtime;        \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:redisServer
unsubscribeCommand	.\pubsub.c	/^void unsubscribeCommand(redisClient *c) {$/;"	f
unsubscribebulk	.\redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
unwatchAllKeys	.\multi.c	/^void unwatchAllKeys(redisClient *c) {$/;"	f
unwatchCommand	.\multi.c	/^void unwatchCommand(redisClient *c) {$/;"	f
updateDictResizePolicy	.\redis.c	/^void updateDictResizePolicy(void) {$/;"	f
updateLRUClock	.\redis.c	/^void updateLRUClock(void) {$/;"	f
updateSlavesWaitingBgsave	.\replication.c	/^void updateSlavesWaitingBgsave(int bgsaveerr) {$/;"	f
update_cksum	.\rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio
update_zmalloc_stat_add	.\zmalloc.c	71;"	d	file:
update_zmalloc_stat_add	.\zmalloc.c	74;"	d	file:
update_zmalloc_stat_alloc	.\zmalloc.c	88;"	d	file:
update_zmalloc_stat_free	.\zmalloc.c	98;"	d	file:
update_zmalloc_stat_sub	.\zmalloc.c	72;"	d	file:
update_zmalloc_stat_sub	.\zmalloc.c	80;"	d	file:
usage	.\redis-cli.c	/^static void usage() {$/;"	f	file:
usage	.\redis.c	/^void usage() {$/;"	f
usec	.\intset.c	/^long long usec(void) {$/;"	f
usec	.\ziplist.c	/^long long usec(void) {$/;"	f
used	.\aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:
used	.\dict.h	/^    unsigned long used;$/;"	m	struct:dictht
used_memory	.\zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory_mutex	.\zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
ustime	.\redis-benchmark.c	/^static long long ustime(void) {$/;"	f	file:
ustime	.\redis.c	/^long long ustime(void) {$/;"	f
v	.\dict.h	/^    } v;$/;"	m	struct:dictEntry	typeref:union:dictEntry::__anon2
val	.\dict.h	/^        void *val;$/;"	m	union:dictEntry::__anon2
valDestructor	.\dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType
valDup	.\dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType
validSyslogFacilities	.\config.c	/^} validSyslogFacilities[] = {$/;"	v	typeref:struct:__anon1	file:
value	.\adlist.h	/^    void *value;$/;"	m	struct:listNode
value	.\config.c	/^    const int       value;$/;"	m	struct:__anon1	file:
vecswap	.\pqsort.c	86;"	d	file:
verbosity	.\redis.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	struct:redisServer
verify	.\ziplist.c	/^void verify(unsigned char *zl, zlentry *e) {$/;"	f
verifyDumpPayload	.\migrate.c	/^int verifyDumpPayload(unsigned char *p, size_t len) {$/;"	f
version	.\redis.c	/^void version() {$/;"	f
votes	.\sentinel.c	/^    unsigned long votes;$/;"	m	struct:sentinelLeader	file:
vptr	.\redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon11
watchCommand	.\multi.c	/^void watchCommand(redisClient *c) {$/;"	f
watchForKey	.\multi.c	/^void watchForKey(redisClient *c, robj *key) {$/;"	f
watchdogScheduleSignal	.\debug.c	/^void watchdogScheduleSignal(int period) {$/;"	f
watchdogSignalHandler	.\debug.c	/^void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {$/;"	f
watchdog_period	.\redis.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	struct:redisServer
watchedKey	.\multi.c	/^typedef struct watchedKey {$/;"	s	file:
watchedKey	.\multi.c	/^} watchedKey;$/;"	t	typeref:struct:watchedKey	file:
watched_keys	.\redis.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	struct:redisDb
watched_keys	.\redis.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	struct:redisClient
weight	.\t_zset.c	/^    double weight;$/;"	m	struct:__anon18	file:
wfds	.\ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	.\ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	.\ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	.\ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
write	.\rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio
writeHandler	.\redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
writing	.\sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:
written	.\redis-benchmark.c	/^    unsigned int written;   \/* Bytes of 'obuf' already written *\/$/;"	m	struct:_client	file:
wrongtypeerr	.\redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
ws	.\memtest.c	/^static struct winsize ws;$/;"	v	typeref:struct:winsize	file:
x	.\rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
xorDigest	.\debug.c	/^void xorDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f
xorObjectDigest	.\debug.c	/^void xorObjectDigest(unsigned char *digest, robj *o) {$/;"	f
yesnotoi	.\config.c	/^int yesnotoi(char *s) {$/;"	f
zaddCommand	.\t_zset.c	/^void zaddCommand(redisClient *c) {$/;"	f
zaddGenericCommand	.\t_zset.c	/^void zaddGenericCommand(redisClient *c, int incr) {$/;"	f
zcalloc	.\zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f
zcardCommand	.\t_zset.c	/^void zcardCommand(redisClient *c) {$/;"	f
zcountCommand	.\t_zset.c	/^void zcountCommand(redisClient *c) {$/;"	f
zfree	.\zmalloc.c	/^void zfree(void *ptr) {$/;"	f
zi	.\redis.h	/^    unsigned char *zi;  \/* Entry in ziplist *\/$/;"	m	struct:__anon9
zi	.\redis.h	/^    unsigned char *zi;$/;"	m	struct:__anon8
zincrbyCommand	.\t_zset.c	/^void zincrbyCommand(redisClient *c) {$/;"	f
zinterstoreCommand	.\t_zset.c	/^void zinterstoreCommand(redisClient *c) {$/;"	f
zipEncodeLength	.\ziplist.c	/^static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {$/;"	f	file:
zipEntry	.\ziplist.c	/^static zlentry zipEntry(unsigned char *p) {$/;"	f	file:
zipIntSize	.\ziplist.c	/^static unsigned int zipIntSize(unsigned char encoding) {$/;"	f	file:
zipLoadInteger	.\ziplist.c	/^static int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {$/;"	f	file:
zipPrevEncodeLength	.\ziplist.c	/^static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipPrevEncodeLengthForceLarge	.\ziplist.c	/^static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {$/;"	f	file:
zipPrevLenByteDiff	.\ziplist.c	/^static int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {$/;"	f	file:
zipRawEntryLength	.\ziplist.c	/^static unsigned int zipRawEntryLength(unsigned char *p) {$/;"	f	file:
zipSaveInteger	.\ziplist.c	/^static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {$/;"	f	file:
zipTryEncoding	.\ziplist.c	/^static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {$/;"	f	file:
ziplistBlobLen	.\ziplist.c	/^size_t ziplistBlobLen(unsigned char *zl) {$/;"	f
ziplistCompare	.\ziplist.c	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {$/;"	f
ziplistDelete	.\ziplist.c	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {$/;"	f
ziplistDeleteRange	.\ziplist.c	/^unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num) {$/;"	f
ziplistFind	.\ziplist.c	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {$/;"	f
ziplistGet	.\ziplist.c	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {$/;"	f
ziplistIndex	.\ziplist.c	/^unsigned char *ziplistIndex(unsigned char *zl, int index) {$/;"	f
ziplistInsert	.\ziplist.c	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f
ziplistLen	.\ziplist.c	/^unsigned int ziplistLen(unsigned char *zl) {$/;"	f
ziplistNew	.\ziplist.c	/^unsigned char *ziplistNew(void) {$/;"	f
ziplistNext	.\ziplist.c	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPrev	.\ziplist.c	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPush	.\ziplist.c	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {$/;"	f
ziplistRepr	.\ziplist.c	/^void ziplistRepr(unsigned char *zl) {$/;"	f
ziplistResize	.\ziplist.c	/^static unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {$/;"	f	file:
zipmapBlobLen	.\zipmap.c	/^size_t zipmapBlobLen(unsigned char *zm) {$/;"	f
zipmapDecodeLength	.\zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	file:
zipmapDel	.\zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f
zipmapEncodeLength	.\zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipmapExists	.\zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f
zipmapGet	.\zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapLen	.\zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f
zipmapLookupRaw	.\zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	file:
zipmapNew	.\zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f
zipmapNext	.\zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapRawEntryLength	.\zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	file:
zipmapRawKeyLength	.\zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	file:
zipmapRawValueLength	.\zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	file:
zipmapRepr	.\zipmap.c	/^void zipmapRepr(unsigned char *p) {$/;"	f
zipmapRequiredLength	.\zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	file:
zipmapResize	.\zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	file:
zipmapRewind	.\zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f
zipmapSet	.\zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f
zl	.\t_zset.c	/^                unsigned char *zl;$/;"	m	struct:__anon18::__anon19::_iterzset::__anon22	file:
zl	.\t_zset.c	/^            } zl;$/;"	m	union:__anon18::__anon19::_iterzset	typeref:struct:__anon18::__anon19::_iterzset::__anon22	file:
zlentry	.\ziplist.c	/^typedef struct zlentry {$/;"	s	file:
zlentry	.\ziplist.c	/^} zlentry;$/;"	t	typeref:struct:zlentry	file:
zlibc_free	.\zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f
zmalloc	.\zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f
zmalloc_default_oom	.\zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	file:
zmalloc_enable_thread_safeness	.\zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f
zmalloc_get_fragmentation_ratio	.\zmalloc.c	/^float zmalloc_get_fragmentation_ratio(void) {$/;"	f
zmalloc_get_private_dirty	.\zmalloc.c	/^size_t zmalloc_get_private_dirty(void) {$/;"	f
zmalloc_get_rss	.\zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f
zmalloc_oom_handler	.\zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	file:
zmalloc_set_oom_handler	.\zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f
zmalloc_size	.\zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f
zmalloc_size	.\zmalloc.h	43;"	d
zmalloc_size	.\zmalloc.h	53;"	d
zmalloc_size	.\zmalloc.h	61;"	d
zmalloc_size_sds	.\networking.c	/^size_t zmalloc_size_sds(sds s) {$/;"	f
zmalloc_thread_safe	.\zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	file:
zmalloc_used_memory	.\zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f
zrangeCommand	.\t_zset.c	/^void zrangeCommand(redisClient *c) {$/;"	f
zrangeGenericCommand	.\t_zset.c	/^void zrangeGenericCommand(redisClient *c, int reverse) {$/;"	f
zrangebyscoreCommand	.\t_zset.c	/^void zrangebyscoreCommand(redisClient *c) {$/;"	f
zrangespec	.\redis.h	/^} zrangespec;$/;"	t	typeref:struct:__anon12
zrankCommand	.\t_zset.c	/^void zrankCommand(redisClient *c) {$/;"	f
zrankGenericCommand	.\t_zset.c	/^void zrankGenericCommand(redisClient *c, int reverse) {$/;"	f
zrealloc	.\zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f
zremCommand	.\t_zset.c	/^void zremCommand(redisClient *c) {$/;"	f
zremrangebyrankCommand	.\t_zset.c	/^void zremrangebyrankCommand(redisClient *c) {$/;"	f
zremrangebyscoreCommand	.\t_zset.c	/^void zremrangebyscoreCommand(redisClient *c) {$/;"	f
zrevrangeCommand	.\t_zset.c	/^void zrevrangeCommand(redisClient *c) {$/;"	f
zrevrangebyscoreCommand	.\t_zset.c	/^void zrevrangebyscoreCommand(redisClient *c) {$/;"	f
zrevrankCommand	.\t_zset.c	/^void zrevrankCommand(redisClient *c) {$/;"	f
zs	.\t_zset.c	/^                zset *zs;$/;"	m	struct:__anon18::__anon19::_iterzset::__anon23	file:
zscanCommand	.\t_zset.c	/^void zscanCommand(redisClient *c) {$/;"	f
zscoreCommand	.\t_zset.c	/^void zscoreCommand(redisClient *c) {$/;"	f
zset	.\redis.h	/^typedef struct zset {$/;"	s
zset	.\redis.h	/^} zset;$/;"	t	typeref:struct:zset
zset	.\t_zset.c	/^        } zset;$/;"	m	union:__anon18::__anon19	typeref:union:__anon18::__anon19::_iterzset	file:
zsetConvert	.\t_zset.c	/^void zsetConvert(robj *zobj, int encoding) {$/;"	f
zsetDictType	.\redis.c	/^dictType zsetDictType = {$/;"	v
zsetLength	.\t_zset.c	/^unsigned int zsetLength(robj *zobj) {$/;"	f
zset_max_ziplist_entries	.\redis.h	/^    size_t zset_max_ziplist_entries;$/;"	m	struct:redisServer
zset_max_ziplist_value	.\redis.h	/^    size_t zset_max_ziplist_value;$/;"	m	struct:redisServer
zsetopsrc	.\t_zset.c	/^} zsetopsrc;$/;"	t	typeref:struct:__anon18	file:
zsetopval	.\t_zset.c	/^} zsetopval;$/;"	t	typeref:struct:__anon24	file:
zskiplist	.\redis.h	/^typedef struct zskiplist {$/;"	s
zskiplist	.\redis.h	/^} zskiplist;$/;"	t	typeref:struct:zskiplist
zskiplistLevel	.\redis.h	/^    struct zskiplistLevel {$/;"	s	struct:zskiplistNode
zskiplistNode	.\redis.h	/^typedef struct zskiplistNode {$/;"	s
zskiplistNode	.\redis.h	/^} zskiplistNode;$/;"	t	typeref:struct:zskiplistNode
zsl	.\redis.h	/^    zskiplist *zsl;$/;"	m	struct:zset
zslCreate	.\t_zset.c	/^zskiplist *zslCreate(void) {$/;"	f
zslCreateNode	.\t_zset.c	/^zskiplistNode *zslCreateNode(int level, double score, robj *obj) {$/;"	f
zslDelete	.\t_zset.c	/^int zslDelete(zskiplist *zsl, double score, robj *obj) {$/;"	f
zslDeleteNode	.\t_zset.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f
zslDeleteRangeByRank	.\t_zset.c	/^unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f
zslDeleteRangeByScore	.\t_zset.c	/^unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec range, dict *dict) {$/;"	f
zslFirstInRange	.\t_zset.c	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec range) {$/;"	f
zslFree	.\t_zset.c	/^void zslFree(zskiplist *zsl) {$/;"	f
zslFreeNode	.\t_zset.c	/^void zslFreeNode(zskiplistNode *node) {$/;"	f
zslGetElementByRank	.\t_zset.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f
zslGetRank	.\t_zset.c	/^unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {$/;"	f
zslInsert	.\t_zset.c	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {$/;"	f
zslIsInRange	.\t_zset.c	/^int zslIsInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslLastInRange	.\t_zset.c	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec range) {$/;"	f
zslParseRange	.\t_zset.c	/^static int zslParseRange(robj *min, robj *max, zrangespec *spec) {$/;"	f	file:
zslRandomLevel	.\t_zset.c	/^int zslRandomLevel(void) {$/;"	f
zslValueGteMin	.\t_zset.c	/^static int zslValueGteMin(double value, zrangespec *spec) {$/;"	f	file:
zslValueLteMax	.\t_zset.c	/^static int zslValueLteMax(double value, zrangespec *spec) {$/;"	f	file:
zstrdup	.\zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f
zuiBufferFromValue	.\t_zset.c	/^int zuiBufferFromValue(zsetopval *val) {$/;"	f
zuiClearIterator	.\t_zset.c	/^void zuiClearIterator(zsetopsrc *op) {$/;"	f
zuiCompareByCardinality	.\t_zset.c	/^int zuiCompareByCardinality(const void *s1, const void *s2) {$/;"	f
zuiFind	.\t_zset.c	/^int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {$/;"	f
zuiInitIterator	.\t_zset.c	/^void zuiInitIterator(zsetopsrc *op) {$/;"	f
zuiLength	.\t_zset.c	/^int zuiLength(zsetopsrc *op) {$/;"	f
zuiLongLongFromValue	.\t_zset.c	/^int zuiLongLongFromValue(zsetopval *val) {$/;"	f
zuiNext	.\t_zset.c	/^int zuiNext(zsetopsrc *op, zsetopval *val) {$/;"	f
zuiObjectFromValue	.\t_zset.c	/^robj *zuiObjectFromValue(zsetopval *val) {$/;"	f
zunionInterAggregate	.\t_zset.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	file:
zunionInterDictValue	.\t_zset.c	1477;"	d	file:
zunionInterGenericCommand	.\t_zset.c	/^void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {$/;"	f
zunionInterGetKeys	.\db.c	/^int *zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys, int flags) {$/;"	f
zunionstoreCommand	.\t_zset.c	/^void zunionstoreCommand(redisClient *c) {$/;"	f
zzlCompareElements	.\t_zset.c	/^int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {$/;"	f
zzlDelete	.\t_zset.c	/^unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {$/;"	f
zzlDeleteRangeByRank	.\t_zset.c	/^unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {$/;"	f
zzlDeleteRangeByScore	.\t_zset.c	/^unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec range, unsigned long *deleted) {$/;"	f
zzlFind	.\t_zset.c	/^unsigned char *zzlFind(unsigned char *zl, robj *ele, double *score) {$/;"	f
zzlFirstInRange	.\t_zset.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec range) {$/;"	f
zzlGetScore	.\t_zset.c	/^double zzlGetScore(unsigned char *sptr) {$/;"	f
zzlInsert	.\t_zset.c	/^unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score) {$/;"	f
zzlInsertAt	.\t_zset.c	/^unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, robj *ele, double score) {$/;"	f
zzlIsInRange	.\t_zset.c	/^int zzlIsInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlLastInRange	.\t_zset.c	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec range) {$/;"	f
zzlLength	.\t_zset.c	/^unsigned int zzlLength(unsigned char *zl) {$/;"	f
zzlNext	.\t_zset.c	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
zzlPrev	.\t_zset.c	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
